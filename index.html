<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Adventure-like (HTML5 Canvas) — Custom Characters</title>
<style>
  :root {
    --bg: #0f1115;
    --panel: #151a21;
    --ink: #e8eef8;
    --muted: #aab4c0;
    --accent: #5fd4ff;
    --accent-2: #89ffa3;
  }
  * { box-sizing: border-box; }
  html, body { height: 100%; background: var(--bg); color: var(--ink); font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif; }
  body { margin: 0; display: grid; grid-template-columns: 320px 1fr; gap: 0; min-height: 100vh; }
  aside {
    background: var(--panel);
    border-right: 1px solid #1f2630;
    padding: 18px 16px 24px;
    overflow: auto;
  }
  h1 { font-size: 16px; margin: 0 0 12px; font-weight: 600; letter-spacing: .2px; }
  h2 { font-size: 12px; margin: 18px 0 10px; text-transform: uppercase; color: var(--muted); letter-spacing: .7px; }
  .row { display: grid; grid-template-columns: 1fr; gap: 8px; margin-bottom: 12px; }
  label { font-size: 13px; color: var(--muted); }
  input[type="file"] {
    width: 100%;
    padding: 8px;
    background: #0e1318;
    border: 1px solid #1f2630;
    color: var(--ink);
    border-radius: 8px;
  }
  button {
    appearance: none; border: 1px solid #1f2630;
    background: #0e1318; color: var(--ink);
    padding: 10px 12px; border-radius: 8px; cursor: pointer;
    font-weight: 600; font-size: 14px;
  }
  button:hover { border-color: #2a3240; }
  .btns { display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 8px; }
  .touch-controls {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(3, 1fr);
    gap: 8px;
    max-width: 200px;
    margin: 16px auto 0;
    touch-action: none;
  }
  .touch-btn {
    min-height: 54px;
    border-radius: 12px;
    border: 1px solid #2a3240;
    background: rgba(12,17,22,.8);
    color: var(--ink);
    font-weight: 600;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
  }
  .touch-btn:active {
    background: rgba(95,212,255,.35);
    border-color: var(--accent);
  }
  .touch-pad {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(3, 1fr);
    gap: 6px;
  }
  .touch-pad .touch-btn {
    min-height: 48px;
    font-size: 18px;
  }
  .touch-actions {
    display: grid;
    grid-template-columns: repeat(2, minmax(0,1fr));
    gap: 8px;
    margin-top: 12px;
  }
  .kbd {
    display: inline-block; padding: 2px 6px; border: 1px solid #2a3240;
    border-bottom-width: 2px; border-radius: 6px; background: #0d1217; font-size: 12px; color: var(--ink);
  }
  .tips { font-size: 13px; color: var(--muted); line-height: 1.4; }
  main { display: grid; place-items: center; padding: 12px; }
  canvas {
    width: min(100%, 960px); height: auto; background: #0b0e13; border: 1px solid #1f2630; border-radius: 12px;
    box-shadow: 0 0 0 1px #0b0e13, 0 6px 30px rgba(0,0,0,.45);
  }
  .hud {
    position: absolute; inset: 12px 12px auto auto; pointer-events: none;
    display: flex; gap: 8px; flex-wrap: wrap; font-size: 12px; color: var(--muted);
  }
  .tag {
    padding: 4px 8px; border: 1px solid #2a3240; border-radius: 999px; background: rgba(17,22,29,.72); backdrop-filter: blur(6px);
  }
  .toast {
    position: absolute; left: 50%; transform: translateX(-50%);
    bottom: 18px; background: rgba(17,22,29,.9); color: var(--ink);
    border: 1px solid #2a3240; padding: 10px 14px; border-radius: 10px; font-size: 14px;
    display: none;
  }
  .toast.show { display: block; }
  @media (max-width: 900px) {
    body {
      grid-template-columns: 1fr;
      grid-template-rows: auto auto;
    }
    main {
      order: 1;
    }
    aside {
      order: 2;
      border-right: none;
      border-top: 1px solid #1f2630;
    }
    canvas {
      width: 100%;
    }
  }
  @media (max-width: 600px) {
    .btns, .touch-actions { grid-template-columns: 1fr; }
    .touch-controls { margin-top: 8px; }
  }
</style>
</head>
<body>
  <aside>
    <h1 id="gameTitle">Kid Adventure</h1>
    <div class="row tips">
      Carry one item at a time. Grab the <b>sword</b> to fight the dragon, pick up the <b>key</b> to unlock castle gates, and return the <b>trophy</b> to the start pedestal to win.
    </div>
    <h2>How to Play</h2>
    <div class="row tips">
      <b>1.</b> Explore to find the sword near the meadow.<br>
      <b>2.</b> Hunt down the dragon (sword defeats it).<br>
      <b>3.</b> Carry the key into castle gates to swing them open—no extra button press needed.<br>
      <b>4.</b> Snag the trophy from the depths and bring it home.<br>
      Gates, dragons, and treasures move around depending on the level you pick.
    </div>

    <div class="row">
      <label for="kidSelect">Choose adventurer</label>
      <select id="kidSelect"></select>
    </div>
    <div class="tips">
      Switching heroes reloads their art instantly and respawns you near the start.
    </div>
    <div class="row">
      <label for="levelSelect">Choose level</label>
      <select id="levelSelect"></select>
    </div>
    <div class="tips">
      Level 1 is the classic grounds, Level 2 adds sprawling catacombs, Level 3 is a huge dragon gauntlet.
    </div>

    <h2>Game</h2>
    <div class="btns">
      <button id="btnReset">Reset (R)</button>
      <button id="btnPause">Pause (P)</button>
    </div>

    <h2>Touch Controls</h2>
    <div class="touch-pad" id="touchPad">
      <div></div>
      <button class="touch-btn" data-dir="up">▲</button>
      <div></div>
      <button class="touch-btn" data-dir="left">◀</button>
      <div></div>
      <button class="touch-btn" data-dir="right">▶</button>
      <div></div>
      <button class="touch-btn" data-dir="down">▼</button>
      <div></div>
    </div>
    <div class="touch-actions">
      <button class="touch-btn" data-action="interact">Use / Pick (E)</button>
      <button class="touch-btn" data-action="drop">Drop (Q)</button>
    </div>

    <h2>Controls</h2>
    <div class="tips">
      Move: <span class="kbd">WASD</span> / <span class="kbd">Arrows</span><br>
      Pick up / Use: <span class="kbd">E</span> &nbsp;·&nbsp; Drop: <span class="kbd">Q</span><br>
    </div>

    <h2>Notes</h2>
    <div class="tips">
      Images are scaled to the entity size after loading from disk. Update the PNGs
      in each kid folder and refresh to see them in game. Transparent backgrounds look best.
      Each reset rotates through curated map variants so the overworld layout always changes
      but stays solvable.
    </div>
  </aside>

  <main>
    <div class="hud" id="hud"></div>
    <canvas id="game" width="960" height="600"></canvas>
    <div class="toast" id="toast"></div>
  </main>

<script>
"use strict";

/* =========================================================
   Basic engine + game objects
   ========================================================= */

const W = 960, H = 600;
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d", { alpha: false });
ctx.imageSmoothingEnabled = false;

const keys = new Set();
const held = (k) => keys.has(k);
addEventListener("keydown", (e) => {
  keys.add(e.key.toLowerCase());
});
addEventListener("keyup", (e) => {
  keys.delete(e.key.toLowerCase());
});

const touchState = {
  up: false,
  down: false,
  left: false,
  right: false
};

function heldDirection(dir) {
  if (touchState[dir]) return true;
  if (dir === "up") return held("arrowup") || held("w");
  if (dir === "down") return held("arrowdown") || held("s");
  if (dir === "left") return held("arrowleft") || held("a");
  if (dir === "right") return held("arrowright") || held("d");
  return false;
}

function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
function resolveItemGateOverlap(item, room, player) {
  if (!room.gate || room.gate.open) return;
  const g = room.gate.rect;
  if (!rectsOverlap(item, g)) return;
  // Nudge item to the side away from the gate so it remains reachable
  if (player.x < g.x) {
    item.x = clamp(g.x - item.w - 6, 8, W - item.w - 8);
  } else {
    item.x = clamp(g.x + g.w + 6, 8, W - item.w - 8);
  }
  item.y = clamp(item.y, 8, H - item.h - 8);
}
function rectsTouchOrOverlap(a, b, pad=0) {
  // Inclusive edges so the player touching the gate can still trigger it
  return (
    a.x - pad <= b.x + b.w &&
    a.x + a.w + pad >= b.x &&
    a.y - pad <= b.y + b.h &&
    a.y + a.h + pad >= b.y
  );
}
function rectsOverlap(a, b) {
  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}
function drawRect(r, color="#fff") {
  ctx.fillStyle = color; ctx.fillRect(r.x, r.y, r.w, r.h);
}
function outlineRect(r, color="#fff") {
  ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.strokeRect(r.x+1, r.y+1, r.w-2, r.h-2);
}
function drawWallRect(r, color="#2a3340", stroke="#11161d") {
  const grad = ctx.createLinearGradient(r.x, r.y, r.x, r.y + r.h);
  grad.addColorStop(0, color);
  grad.addColorStop(1, "#1b222c");
  ctx.fillStyle = grad;
  ctx.fillRect(r.x, r.y, r.w, r.h);
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 2;
  ctx.strokeRect(r.x + 1, r.y + 1, r.w - 2, r.h - 2);
}
function drawImageOrFallback(img, r, color, label) {
  if (img && img.complete && img.naturalWidth > 0) {
    const imgRatio = img.naturalWidth / img.naturalHeight;
    const rectRatio = r.w / r.h;
    let dw, dh;
    if (imgRatio > rectRatio) {
      dw = r.w;
      dh = dw / imgRatio;
    } else {
      dh = r.h;
      dw = dh * imgRatio;
    }
    const dx = r.x + (r.w - dw) / 2;
    const dy = r.y + (r.h - dh) / 2;
    ctx.drawImage(img, dx|0, dy|0, dw|0, dh|0);
  } else {
    drawRect(r, color);
    if (label) {
      ctx.fillStyle = "rgba(0,0,0,.7)";
      ctx.font = "bold 12px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(label, r.x + r.w/2, r.y + r.h/2);
    }
  }
}
function showToast(text, ms=1600) {
  const t = document.getElementById("toast");
  t.textContent = text;
  t.classList.add("show");
  clearTimeout(showToast._id);
  showToast._id = setTimeout(()=>t.classList.remove("show"), ms);
}

function drawCastleSilhouette(cfg={}) {
  const {
    color = "#d8c16f",
    outline = "#3b3523",
    accent = "#f7e69b",
    roof = "#a67c3e",
    towers = 2,
    door = "west",
    label = "",
    x = 220,
    y = 80,
    w = 520,
    h = 360
  } = cfg;

  const towerWidth = Math.min(70, w * 0.15);
  const towerHeight = h + 40;
  ctx.fillStyle = color;
  ctx.fillRect(x, y, w, h);
  ctx.strokeStyle = outline;
  ctx.lineWidth = 4;
  ctx.strokeRect(x, y, w, h);

  for (let i=0; i<towers; i++) {
    const offset = Math.min(30, towerWidth * 0.6);
    const tx = i === 0 ? x - offset : x + w - towerWidth + offset/2;
    ctx.fillStyle = color;
    ctx.fillRect(tx, y - 10, towerWidth, towerHeight);
    ctx.strokeRect(tx, y - 10, towerWidth, towerHeight);
    ctx.fillStyle = roof;
    ctx.beginPath();
    ctx.moveTo(tx - 10, y - 10);
    ctx.lineTo(tx + towerWidth/2, y - 60);
    ctx.lineTo(tx + towerWidth + 10, y - 10);
    ctx.closePath();
    ctx.fill();
  }

  const crenelCount = Math.floor(w / 40);
  for (let i=0; i<crenelCount; i++) {
    const span = w / crenelCount;
    ctx.fillStyle = accent;
    ctx.fillRect(x + i*span + 6, y - 18, span - 12, 18);
    ctx.strokeRect(x + i*span + 6, y - 18, span - 12, 18);
  }

  const windowCount = Math.max(2, Math.floor(w / 120));
  const windowW = 24, windowH = 36;
  ctx.fillStyle = "rgba(0,0,0,0.45)";
  for (let i=0; i<windowCount; i++) {
    const wx = x + (i+1) * (w/(windowCount+1)) - windowW/2;
    const wy = y + h/3;
    ctx.fillRect(wx, wy, windowW, windowH);
    ctx.fillRect(wx, wy + 80, windowW, windowH);
  }

  const doorW = 90, doorH = 130;
  let doorX = x + w/2 - doorW/2;
  let doorY = y + h - doorH;
  if (door === "west") {
    doorX = x - doorW/2 + 10;
    doorY = y + h/2 - doorH/2;
  } else if (door === "east") {
    doorX = x + w - doorW/2 - 10;
    doorY = y + h/2 - doorH/2;
  } else if (door === "north") {
    doorX = x + w/2 - doorW/2;
    doorY = y - doorH/2;
  }
  ctx.fillStyle = "#1b1c23";
  ctx.fillRect(doorX, doorY, doorW, doorH);
  ctx.strokeRect(doorX, doorY, doorW, doorH);

  if (label) {
    ctx.fillStyle = accent;
    ctx.font = "bold 16px system-ui, sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(label.toUpperCase(), x + w/2, y + h + 28);
  }
}

function addBoundaryWalls(room, options={}) {
  const thickness = options.thickness ?? 16;
  const gap = options.gap ?? 140;
  const open = Object.assign(
    { north: false, south: false, east: false, west: false },
    options.open || {}
  );
  const halfGap = gap / 2;
  const cx = W / 2;
  const cy = H / 2;

  // Top wall
  if (open.north) {
    if (cx - halfGap > 0) room.walls.push({ x: 0, y: 0, w: cx - halfGap, h: thickness });
    if (cx + halfGap < W) room.walls.push({ x: cx + halfGap, y: 0, w: W - (cx + halfGap), h: thickness });
  } else {
    room.walls.push({ x: 0, y: 0, w: W, h: thickness });
  }

  // Bottom wall
  if (open.south) {
    if (cx - halfGap > 0) room.walls.push({ x: 0, y: H - thickness, w: cx - halfGap, h: thickness });
    if (cx + halfGap < W) room.walls.push({ x: cx + halfGap, y: H - thickness, w: W - (cx + halfGap), h: thickness });
  } else {
    room.walls.push({ x: 0, y: H - thickness, w: W, h: thickness });
  }

  // Left wall
  if (open.west) {
    if (cy - halfGap > 0) room.walls.push({ x: 0, y: 0, w: thickness, h: cy - halfGap });
    if (cy + halfGap < H) room.walls.push({ x: 0, y: cy + halfGap, w: thickness, h: H - (cy + halfGap) });
  } else {
    room.walls.push({ x: 0, y: 0, w: thickness, h: H });
  }

  // Right wall
  if (open.east) {
    if (cy - halfGap > 0) room.walls.push({ x: W - thickness, y: 0, w: thickness, h: cy - halfGap });
    if (cy + halfGap < H) room.walls.push({ x: W - thickness, y: cy + halfGap, w: thickness, h: H - (cy + halfGap) });
  } else {
    room.walls.push({ x: W - thickness, y: 0, w: thickness, h: H });
  }
}

function createRoomAdder(world) {
  return function addRoom(id, name, options={}, setup) {
    const room = new Room(id, name, options);
    world.rooms[id] = room;
    if (typeof setup === "function") setup(room);
    return room;
  };
}

/* =========================================================
   Assets (loaded from kid-specific directories)
   ========================================================= */
const DEFAULT_KID_ID = "eli";
const ASSET_CONFIG = {
  eli: {
    displayName: "Eli",
    assets: {
      player: "assets/kids/eli/player.png",
      dragon: "assets/common/dragon.png",
      dragonDead: "assets/common/dragon-dead.png",
      key: "assets/common/key.png",
      sword: "assets/common/sword.png",
      trophy: "assets/common/trophy.png"
    }
  },
  isla: {
    displayName: "Isla",
    assets: {
      player: "assets/kids/isla/player.png",
      dragon: "assets/common/dragon.png",
      dragonDead: "assets/common/dragon-dead.png",
      key: "assets/common/key.png",
      sword: "assets/common/sword.png",
      trophy: "assets/common/trophy.png"
    }
  },
  kylie: {
    displayName: "Kylie",
    assets: {
      player: "assets/kids/kylie/player.png",
      dragon: "assets/common/dragon.png",
      dragonDead: "assets/common/dragon-dead.png",
      key: "assets/common/key.png",
      sword: "assets/common/sword.png",
      trophy: "assets/common/trophy.png"
    }
  }
};

const LEVEL_CONFIG = {
  l1: {
    label: "Level 1 – Garden Patrol",
    variants: ["classic", "shuffled"]
  },
  l2: {
    label: "Level 2 – Labyrinth Trek",
    variants: ["labyrinth", "catacombs"]
  },
  l3: {
    label: "Level 3 – Dragon Gauntlet",
    variants: ["highlands", "gauntlet"]
  }
};

const DEFAULT_LEVEL_ID = "l1";
const searchParams = new URLSearchParams(location.search);
const queryKid = searchParams.get("kid");
const queryLevel = searchParams.get("level");
let activeKidId = (queryKid && ASSET_CONFIG[queryKid]) ? queryKid : DEFAULT_KID_ID;
let activeKidName = ASSET_CONFIG[activeKidId]?.displayName || "Default Hero";
let activeLevelId = (queryLevel && LEVEL_CONFIG[queryLevel]) ? queryLevel : DEFAULT_LEVEL_ID;
let activeLevelName = LEVEL_CONFIG[activeLevelId]?.label || LEVEL_CONFIG[DEFAULT_LEVEL_ID].label;
const IMAGES = { player: null, dragon: null, dragonDead: null, key: null, sword: null, trophy: null };

function loadKidAssets(kidId) {
  const kid = ASSET_CONFIG[kidId] || ASSET_CONFIG[DEFAULT_KID_ID];
  activeKidName = kid.displayName || kidId;
  updateAdventureTitle();
  Object.entries(kid.assets).forEach(([key, url]) => loadAssetImage(key, url));
}

function loadAssetImage(key, url) {
  const img = new Image();
  img.onload = () => { IMAGES[key] = img; };
  img.onerror = () => {
    console.warn(`Failed to load asset ${key} from ${url}. Using fallback.`);
    IMAGES[key] = null;
  };
  img.src = url;
}

function populateKidSelector() {
  const select = document.getElementById("kidSelect");
  if (!select) return;
  select.innerHTML = "";
  Object.entries(ASSET_CONFIG).forEach(([id, cfg]) => {
    const opt = document.createElement("option");
    opt.value = id;
    opt.textContent = cfg.displayName || id;
    select.appendChild(opt);
  });
  select.value = activeKidId;
  select.addEventListener("change", (event) => {
    const nextId = event.target.value;
    if (!ASSET_CONFIG[nextId]) return;
    activeKidId = nextId;
    loadKidAssets(activeKidId);
    syncQueryParams();
    const label = ASSET_CONFIG[activeKidId].displayName || activeKidId;
    showToast(`Now playing as ${label}`);
    WORLD.resetPlayerToStart(false);
  });
}

function populateLevelSelector() {
  const select = document.getElementById("levelSelect");
  if (!select) return;
  select.innerHTML = "";
  Object.entries(LEVEL_CONFIG).forEach(([id, cfg]) => {
    const opt = document.createElement("option");
    opt.value = id;
    opt.textContent = cfg.label;
    select.appendChild(opt);
  });
  select.value = activeLevelId;
  select.addEventListener("change", (event) => {
    const nextId = event.target.value;
    if (!LEVEL_CONFIG[nextId]) return;
    activeLevelId = nextId;
    activeLevelName = LEVEL_CONFIG[activeLevelId]?.label || LEVEL_CONFIG[DEFAULT_LEVEL_ID].label;
    syncQueryParams();
    showToast(`Level set to ${activeLevelName}`);
    WORLD.resetAll();
  });
}

function syncQueryParams() {
  const url = new URL(window.location.href);
  if (activeKidId === DEFAULT_KID_ID) url.searchParams.delete("kid"); else url.searchParams.set("kid", activeKidId);
  if (activeLevelId === DEFAULT_LEVEL_ID) url.searchParams.delete("level"); else url.searchParams.set("level", activeLevelId);
  history.replaceState(null, "", url);
}

function updateAdventureTitle() {
  const titleEl = document.getElementById("gameTitle");
  if (!titleEl) return;
  const suffix = activeKidName.endsWith("s") ? "'" : "'s";
  titleEl.textContent = `${activeKidName}${suffix} Adventure`;
}

loadKidAssets(activeKidId);
populateKidSelector();
populateLevelSelector();
updateAdventureTitle();

/* =========================================================
   World + Rooms (2x2 grid)
   ========================================================= */

class Gate {
  constructor(x,y,w,h, options={}) {
    this.rect = { x, y, w, h };
    this.open = options.open ?? false;
    this.requiredKey = options.requiredKey ?? "key";
    this.targetRoom = options.targetRoom || null;
    this.targetDir = options.targetDir || "default";
    this.targetEntry = options.targetEntry || null;
    this.closedColor = options.closedColor || "rgba(68,187,109,0.55)";
  }
  tryOpen(player) {
    if (!this.open && player.holding && player.holding.kind === this.requiredKey && rectsTouchOrOverlap(player, this.rect, 2)) {
      this.open = true;
      showToast("Gate opened");
    }
  }
  tryEnter(player) {
    if (!this.open || !this.targetRoom) return;
    if (rectsOverlap(player, this.rect)) {
      WORLD.transitionTo(this.targetRoom, this.targetDir, { overrides: this.targetEntry || {}, carryHeld: true });
    }
  }
  blockRect() { return this.open ? null : this.rect; }
  draw() {
    if (this.open) {
      // open gate "posts"
      const postW = Math.min(14, this.rect.w/3);
      drawRect({x:this.rect.x, y:this.rect.y, w:postW, h:this.rect.h}, "#2b9154");
      drawRect({x:this.rect.x+this.rect.w-postW, y:this.rect.y, w:postW, h:this.rect.h}, "#2b9154");
    } else {
      drawRect(this.rect, this.closedColor);
      outlineRect(this.rect, "#2b9154");
      // horizontal bar across the door for clarity
      ctx.fillStyle = "#2b9154";
      ctx.fillRect(this.rect.x, this.rect.y + this.rect.h/2 - 6, this.rect.w, 12);
    }
  }
}

class Item {
  constructor(kind, x,y,w,h) {
    this.kind = kind; // "key" | "sword" | "trophy"
    this.x=x; this.y=y; this.w=w; this.h=h;
    this.heldBy = null;
    this.alive = true;
    this.roomId = null;
  }
  rect(){ return this; }
  draw() {
    const r = this.rect();
    let img = null, color = "#888", label = "";
    if (this.kind === "key") { img = IMAGES.key; color="#ffcc00"; label="KEY"; }
    if (this.kind === "sword") { img = IMAGES.sword; color="#dfe6ef"; label="SWORD"; }
    if (this.kind === "trophy") { img = IMAGES.trophy; color="#f7b500"; label="TROPHY"; }
    drawImageOrFallback(img, r, color, label);
    outlineRect(r, "rgba(0,0,0,.35)");
  }
}

class Dragon {
  constructor(x,y) {
    this.x=x; this.y=y; this.w=84; this.h=64;
    this.speed = 180;
    this.alive = true;
    this.wanderTimer = 0;
    this.wanderDir = { x: 0, y: 0 };
  }
  rect(){ return this; }
  update(dt, room, player) {
    if (!this.alive) return;
    // target seeking inside room bounds
    const toPlayerX = (player.x + player.w/2) - (this.x + this.w/2);
    const toPlayerY = (player.y + player.h/2) - (this.y + this.h/2);
    const dist = Math.hypot(toPlayerX, toPlayerY);
    let vx = 0, vy = 0;
    if (dist < 800) { // aggro
      vx = (toPlayerX / (dist||1)) * this.speed;
      vy = (toPlayerY / (dist||1)) * this.speed;
    } else {
      // idle drift with occasional turns
      this.wanderTimer -= dt;
      if (this.wanderTimer <= 0) {
        const angle = Math.random() * Math.PI * 2;
        this.wanderDir.x = Math.cos(angle);
        this.wanderDir.y = Math.sin(angle);
        this.wanderTimer = 1 + Math.random() * 2;
      }
      vx = this.wanderDir.x * 60;
      vy = this.wanderDir.y * 60;
    }
    this._move(vx*dt, vy*dt, room);
    // attack
    if (rectsOverlap(this, player) && !player.invulnTimer) {
      player.onHit();
    }
  }
  _move(dx, dy, room) {
    const solids = room.solidRects();
    this.x += dx;
    for (const s of solids) if (rectsOverlap(this, s)) {
      if (dx > 0) this.x = s.x - this.w; else if (dx < 0) this.x = s.x + s.w;
    }
    this.y += dy;
    for (const s of solids) if (rectsOverlap(this, s)) {
      if (dy > 0) this.y = s.y - this.h; else if (dy < 0) this.y = s.y + s.h;
    }
    this.x = clamp(this.x, 0, W - this.w);
    this.y = clamp(this.y, 0, H - this.h);
  }
  draw() {
    const r = this.rect();
    if (this.alive) {
      drawImageOrFallback(IMAGES.dragon, r, "#d54b4b", "DRAGON");
    } else {
      drawImageOrFallback(IMAGES.dragonDead, r, "#5d5d5d", "DEFEATED");
    }
    outlineRect(r, "rgba(0,0,0,.35)");
  }
}

class Player {
  constructor() {
    this.x=40; this.y=H/2-20; this.w=48; this.h=48;
    this.speed = 210;
    this.holding = null; // Item
    this.invulnTimer = 0;
  }
  rect(){ return this; }
  update(dt, room) {
    // movement
    let dx=0, dy=0;
    if (heldDirection("left")) dx -= 1;
    if (heldDirection("right")) dx += 1;
    if (heldDirection("up")) dy -= 1;
    if (heldDirection("down")) dy += 1;
    if (dx || dy) {
      const mag = Math.hypot(dx, dy) || 1;
      dx = (dx/mag) * this.speed * dt;
      dy = (dy/mag) * this.speed * dt;
    }
    this._move(dx, dy, room);

    // gate interaction
    if (room.gate) {
      room.gate.tryOpen(this);
      room.gate.tryEnter(this);
    }

    // pick / drop
    if (wasPressed("e") || touchActionPressed("interact")) {
      if (this.holding) {
        // use on gate if touching it and it's closed
        // otherwise do nothing here; dropping is Q
      } else {
        // try pick up nearest item overlapping
        for (const it of room.items) {
          if (it.alive && !it.heldBy && rectsOverlap(this, it)) {
            WORLD.removeItemFromRoom(it);
            this.holding = it; it.heldBy = this;
            showToast(`Picked up ${it.kind}`);
            break;
          }
        }
      }
    }
    if (wasPressed("q") || touchActionPressed("drop")) {
      if (this.holding) {
        const it = this.holding;
        it.heldBy = null; this.holding = null;
        it.x = clamp(this.x + this.w + 6, 8, W - it.w - 8);
        it.y = clamp(this.y + (this.h - it.h)/2, 8, H - it.h - 8);
        resolveItemGateOverlap(it, room, this);
        WORLD.addItemToRoom(it, WORLD.currentRoomId);
        showToast("Dropped item");
      }
    }

    // carry follow
    if (this.holding) {
      const it = this.holding;
      it.x = this.x + this.w + 4;
      it.y = this.y + (this.h - it.h)/2;
    }

    if (this.invulnTimer > 0) this.invulnTimer -= dt;
  }
  _move(dx, dy, room) {
    const solids = room.solidRects();
    this.x += dx;
    for (const s of solids) if (rectsOverlap(this, s)) {
      if (dx > 0) this.x = s.x - this.w; else if (dx < 0) this.x = s.x + s.w;
    }
    this.y += dy;
    for (const s of solids) if (rectsOverlap(this, s)) {
      if (dy > 0) this.y = s.y - this.h; else if (dy < 0) this.y = s.y + s.h;
    }

    // room edge travel
    if (this.x + this.w > W) {
      const target = room.neighbors.east;
      if (target) {
        const newY = clamp(this.y, 32, H - this.h - 32);
        WORLD.transitionTo(target, "west", { overrides: { y: newY }, carryHeld: true });
        return;
      } else {
        this.x = W - this.w;
      }
    }
    if (this.x < 0) {
      const target = room.neighbors.west;
      if (target) {
        const newY = clamp(this.y, 32, H - this.h - 32);
        WORLD.transitionTo(target, "east", { overrides: { y: newY }, carryHeld: true });
        return;
      } else {
        this.x = 0;
      }
    }
    if (this.y + this.h > H) {
      const target = room.neighbors.south;
      if (target) {
        const newX = clamp(this.x, 32, W - this.w - 32);
        WORLD.transitionTo(target, "north", { overrides: { x: newX }, carryHeld: true });
        return;
      } else {
        this.y = H - this.h;
      }
    }
    if (this.y < 0) {
      const target = room.neighbors.north;
      if (target) {
        const newX = clamp(this.x, 32, W - this.w - 32);
        WORLD.transitionTo(target, "south", { overrides: { x: newX }, carryHeld: true });
        return;
      } else {
        this.y = 0;
      }
    }
  }
  onHit() {
    this.invulnTimer = 1.2;
    showToast("You were eaten! Back to start...");
    WORLD.resetPlayerToStart(true);
  }
  draw() {
    const r = this.rect();
    drawImageOrFallback(IMAGES.player, r, "#ffd54a", "PLAYER");
    if (this.invulnTimer > 0) {
      ctx.globalAlpha = 0.35 + 0.25*Math.sin(perfNow()*0.02);
      outlineRect(r, "#ffe082");
      ctx.globalAlpha = 1;
    } else {
      outlineRect(r, "rgba(0,0,0,.35)");
    }
  }
}

class Room {
  constructor(id, name, options={}) {
    this.id = id;
    this.name = name;
    this.neighbors = options.neighbors || {};
    this.entryPoints = options.entryPoints || {};
    this.bgColor = options.bgColor || "#0b0f15";
    this.walls = [];
    this.items = [];
    this.enemies = [];
    this.gate = null;
    this.pedestal = null;
  }
  solidRects() {
    const solids = [...this.walls];
    if (this.gate && !this.gate.open) solids.push(this.gate.rect);
    return solids;
  }
  entryPoint(dir="default") {
    return this.entryPoints[dir] || this.entryPoints.default || null;
  }
  drawBackdrop() {
    // mild vignette grid for flavor
    ctx.fillStyle = this.bgColor;
    ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = "#0f141b";
    ctx.lineWidth = 1;
    const grid = 48;
    ctx.beginPath();
    for (let x=0; x<=W; x+=grid){ ctx.moveTo(x+.5,0); ctx.lineTo(x+.5,H); }
    for (let y=0; y<=H; y+=grid){ ctx.moveTo(0,y+.5); ctx.lineTo(W,y+.5); }
    ctx.stroke();
  }
  draw() {
    this.drawBackdrop();
    // walls first
    for (const w of this.walls) { drawWallRect(w, "#2d3542", "#11161d"); }
    // pedestal
    if (this.pedestal) {
      drawRect(this.pedestal, "#343b46");
      outlineRect(this.pedestal, "#4b5564");
      ctx.fillStyle = "#aab4c0";
      ctx.font = "bold 12px system-ui,sans-serif";
      ctx.textAlign="center"; ctx.textBaseline="top";
      ctx.fillText("PEDESTAL", this.pedestal.x + this.pedestal.w/2, this.pedestal.y + this.pedestal.h + 4);
    }
    // castle overlay for clarity
    if (this.castle) {
      drawCastleSilhouette(this.castle);
    }
    // gate on top
    if (this.gate) this.gate.draw();
    // items (not held)
    for (const it of this.items) if (it.alive && !it.heldBy) it.draw();
    // enemies
    for (const e of this.enemies) if (e.alive) e.draw();
  }
}

const START_ROOM_ID = "meadow";
const WORLD = {
  rooms: {},
  currentRoomId: START_ROOM_ID,
  currentLayoutId: null,
  currentLayoutName: "",
  player: new Player(),
  buildRandomLayout() {
    const level = LEVEL_CONFIG[activeLevelId] || LEVEL_CONFIG[DEFAULT_LEVEL_ID];
    const variantIds = (level?.variants || []).filter(id => LAYOUT_VARIANTS[id]);
    const fallbackIds = Object.keys(LAYOUT_VARIANTS);
    const idsToUse = variantIds.length ? variantIds : fallbackIds;
    let pool = idsToUse.filter(id => id !== this.currentLayoutId);
    if (!pool.length) pool = idsToUse;
    const choiceId = pool[Math.floor(Math.random() * pool.length)];
    const variant = LAYOUT_VARIANTS[choiceId];
    this.currentLayoutId = choiceId;
    this.currentLayoutName = `${level.label} · ${variant.label}`;
    variant.builder(this);
  },
  addItemToRoom(item, roomId) {
    const room = this.rooms[roomId];
    if (!room) return;
    item.roomId = roomId;
    room.items.push(item);
  },
  removeItemFromRoom(item) {
    if (!item.roomId) return;
    const room = this.rooms[item.roomId];
    if (room) {
      const idx = room.items.indexOf(item);
      if (idx >= 0) room.items.splice(idx, 1);
    }
    item.roomId = null;
  },
  current() {
    return this.rooms[this.currentRoomId];
  },
  transitionTo(roomId, incomingDir="default", opts={}) {
    const room = this.rooms[roomId];
    if (!room) return;
    this.currentRoomId = roomId;
    const defaults = this.defaultEntry(incomingDir);
    const target = room.entryPoint(incomingDir) || {};
    const overrides = opts.overrides || {};
    const spawn = {
      x: overrides.x ?? target.x ?? defaults.x,
      y: overrides.y ?? target.y ?? defaults.y
    };
    this.player.x = clamp(spawn.x ?? W/2 - this.player.w/2, 16, W - this.player.w - 16);
    this.player.y = clamp(spawn.y ?? H/2 - this.player.h/2, 16, H - this.player.h - 16);
    if (opts.carryHeld && this.player.holding) {
      this.player.holding.x = this.player.x + this.player.w + 4;
      this.player.holding.y = this.player.y + (this.player.h - this.player.holding.h)/2;
    }
    if (!opts.silent) {
      showToast(`Entered: ${room.name}`, 900);
    }
  },
  defaultEntry(dir="default") {
    const margin = 28;
    const p = this.player || { x: W/2 - 24, y: H/2 - 24, w: 48, h: 48 };
    switch (dir) {
      case "west":
        return { x: margin, y: clamp(p.y, margin, H - p.h - margin) };
      case "east":
        return { x: W - p.w - margin, y: clamp(p.y, margin, H - p.h - margin) };
      case "north":
        return { x: clamp(p.x, margin, W - p.w - margin), y: margin };
      case "south":
        return { x: clamp(p.x, margin, W - p.w - margin), y: H - p.h - margin };
      default:
        return { x: 80, y: H/2 - p.h/2 };
    }
  },
  update(dt) {
    const room = this.current();
    for (const d of room.enemies) d.update(dt, room, this.player);
    this.player.update(dt, room);

    if (this.player.holding && this.player.holding.kind === "sword") {
      for (const e of room.enemies) {
        if (e.alive && rectsOverlap(this.player.holding, e)) {
          e.alive = false;
          showToast("Dragon defeated!");
        }
      }
    }

    if (room.pedestal) {
      const ped = room.pedestal;
      for (const itm of room.items) {
        if (itm.kind === "trophy" && itm.alive && !itm.heldBy && rectsOverlap(itm, ped)) {
          state.winTimer = Math.max(state.winTimer, 0.001);
        }
      }
    }
  },
  draw() {
    const room = this.current();
    room.draw();
    if (this.player.holding) this.player.holding.draw();
    this.player.draw();
  },
  resetPlayerToStart(dropHeld) {
    const held = this.player.holding;
    this.transitionTo(START_ROOM_ID, "default", { silent: dropHeld });
    if (held && dropHeld) {
      held.heldBy = null;
      this.player.holding = null;
      this.addItemToRoom(held, this.currentRoomId);
      held.x = this.player.x + this.player.w + 6;
      held.y = this.player.y + (this.player.h - held.h)/2;
    } else if (held) {
      held.x = this.player.x + this.player.w + 4;
      held.y = this.player.y + (this.player.h - held.h)/2;
    }
  },
  resetAll() {
    this.player = new Player();
    this.buildRandomLayout();
    this.transitionTo(START_ROOM_ID, "default", { silent: true });
    state.winTimer = 0;
    if (this.currentLayoutName) {
      showToast(`Layout: ${this.currentLayoutName}`, 2000);
    }
  }
};

const LAYOUT_VARIANTS = {
  classic: { label: "Classic Grounds", builder: buildClassicLayout },
  shuffled: { label: "Shuffled Paths", builder: buildShuffledLayout },
  labyrinth: { label: "Labyrinth Run", builder: buildLabyrinthLayout },
  catacombs: { label: "Catacombs", builder: buildCatacombsLayout },
  highlands: { label: "Highlands", builder: buildHighlandsLayout },
  gauntlet: { label: "Dragon Gauntlet", builder: buildGauntletLayout }
};

function buildClassicLayout(world) {
  world.rooms = {};
  const addRoom = createRoomAdder(world);

  addRoom("meadow", "Yellow Castle Grounds", {
    neighbors: { east: "yellowCourtyard", south: "riverbank" },
    entryPoints: { default: { x: 72, y: H/2 - 24 } },
    bgColor: "#162316"
  }, (room) => {
    addBoundaryWalls(room, { open: { east: true, south: true } });
    room.walls.push(
      { x: 200, y: 140, w: 20, h: 320 },
      { x: 360, y: 140, w: 20, h: 320 }
    );
  });

  addRoom("yellowCourtyard", "Yellow Castle Gate", {
    neighbors: { west: "meadow" },
    bgColor: "#1e1d26"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.entryPoints = {
      west: { x: 80, y: H/2 - 40 },
      east: { x: W - 180, y: H/2 - 40 }
    };
    room.castle = { color: "#f4d26a", accent: "#fff2a1", door: "west", label: "Yellow Castle", x: 280, y: 120, w: 360, h: 280 };
    room.walls = [];
    room.gate = new Gate(280 + 360/2 - 45, 120 + 280 - 130, 90, 120, {
      targetRoom: "yellowHall",
      targetDir: "west",
      targetEntry: { x: 140, y: H/2 - 30 },
      requiredKey: "key",
      open: false
    });
  });

  addRoom("yellowHall", "Yellow Castle Interior", {
    neighbors: { west: "yellowCourtyard" },
    entryPoints: { default: { x: 120, y: H/2 - 30 } },
    bgColor: "#2a2415"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#9d8435", accent: "#ffe4a6", door: "east", label: "Throne Room", x: 180, y: 120, w: 520, h: 280 };
    room.walls.push(
      { x: 300, y: 160, w: 20, h: 280 },
      { x: 500, y: 120, w: 20, h: 360 }
    );
  });

  addRoom("riverbank", "Riverbank", {
    neighbors: { north: "meadow", east: "woods", south: "swamp" },
    bgColor: "#0b1e2b"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true, south: true } });
    room.walls.push(
      { x: 0, y: H/2 - 60, w: 320, h: 60 },
      { x: 580, y: H/2 - 60, w: 380, h: 60 },
      { x: 220, y: 0, w: 20, h: H/2 - 120 },
      { x: 520, y: H/2, w: 20, h: H/2 }
    );
  });

  addRoom("woods", "Dark Woods", {
    neighbors: { west: "riverbank", east: "blackEntrance" },
    bgColor: "#192011"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
    room.walls.push(
      { x: 160, y: 80, w: 40, h: 440 },
      { x: 360, y: 120, w: 40, h: 360 },
      { x: 560, y: 80, w: 40, h: 440 }
    );
  });

  addRoom("blackEntrance", "Black Castle Gate", {
    neighbors: { west: "woods", east: "blackHall" },
    bgColor: "#111"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
    room.castle = { color: "#444", accent: "#bbb", door: "west", label: "Black Castle", x: 260, y: 140, w: 400, h: 260 };
    room.walls.push(
      { x: 260, y: 160, w: 20, h: 260 },
      { x: 520, y: 160, w: 20, h: 260 }
    );
  });

  addRoom("blackHall", "Black Castle Interior", {
    neighbors: { west: "blackEntrance" },
    bgColor: "#1c1c1c"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#2b2b2b", accent: "#e1e1e1", door: "east", label: "Dungeon", x: 220, y: 100, w: 520, h: 300 };
    room.walls.push(
      { x: 380, y: 120, w: 20, h: 360 }
    );
  });

  addRoom("swamp", "Swamp", {
    neighbors: { north: "riverbank", east: "greenMaze", south: "dragonLair" },
    bgColor: "#132018"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true, south: true } });
    room.walls.push(
      { x: 160, y: 160, w: 120, h: 120 },
      { x: 420, y: 100, w: 40, h: 180 },
      { x: 620, y: 320, w: 80, h: 160 }
    );
  });

  addRoom("greenMaze", "Green Maze", {
    neighbors: { west: "swamp", east: "greenEntrance" },
    bgColor: "#0f2a1d"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
    room.walls.push(
      { x: 200, y: 80, w: 20, h: 400 },
      { x: 200, y: 80, w: 240, h: 20 },
      { x: 440, y: 80, w: 20, h: 360 },
      { x: 440, y: 420, w: 200, h: 20 },
      { x: 640, y: 140, w: 20, h: 320 }
    );
  });

  addRoom("greenEntrance", "Green Castle Gate", {
    neighbors: { west: "greenMaze", east: "greenHall" },
    bgColor: "#1b2a15"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
    room.gate = new Gate(W/2 - 45, H/2 - 60, 90, 120, {
      targetRoom: "greenHall",
      targetDir: "west",
      targetEntry: { x: 140, y: H/2 - 26 },
      requiredKey: "key",
      open: true
    });
    room.castle = { color: "#4c6f3f", accent: "#aee09a", door: "west", label: "Green Castle", x: 260, y: 140, w: 420, h: 260 };
    room.walls.push(
      { x: 260, y: 140, w: 20, h: 320 },
      { x: 520, y: 140, w: 20, h: 320 }
    );
  });

  addRoom("greenHall", "Green Castle Interior", {
    neighbors: { west: "greenEntrance" },
    bgColor: "#2d3f23",
    entryPoints: { west: { x: 140, y: H/2 - 26 }, default: { x: 140, y: H/2 - 26 } }
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#36502f", accent: "#d8ffc4", door: "east", label: "Treasure Room", x: 220, y: 120, w: 520, h: 280 };
    room.walls.push(
      { x: 320, y: 120, w: 20, h: 360 }
    );
  });

  addRoom("dragonLair", "Dragon Lair", {
    neighbors: { north: "swamp" },
    bgColor: "#250c0c"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true } });
    room.walls.push(
      { x: 220, y: 100, w: 520, h: 40 },
      { x: 220, y: 100, w: 40, h: 360 },
      { x: 220, y: 420, w: 520, h: 40 },
      { x: 700, y: 140, w: 40, h: 280 }
    );
  });

  world.addItemToRoom(new Item("sword", 220, H/2 - 16, 64, 24), "meadow");
  // Key placed near gate for easy access
  world.addItemToRoom(new Item("key", 360, H/2 + 40, 42, 26), "yellowCourtyard");
  world.addItemToRoom(new Item("trophy", W - 260, H/2 - 24, 44, 36), "greenHall");

  const dragon = new Dragon(W - 260, H/2 - 32);
  world.rooms.dragonLair.enemies.push(dragon);

  world.currentRoomId = START_ROOM_ID;
}

function buildShuffledLayout(world) {
  world.rooms = {};
  const addRoom = createRoomAdder(world);

  addRoom("meadow", "Hidden Meadow", {
    neighbors: { north: "woods", east: "riverbank", south: "yellowCourtyard" },
    entryPoints: { default: { x: 72, y: H/2 - 24 } },
    bgColor: "#1a2416"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true, south: true } });
    room.walls.push(
      { x: 180, y: 160, w: 20, h: 280 },
      { x: 420, y: 120, w: 20, h: 360 },
      { x: 640, y: 160, w: 20, h: 280 }
    );
  });

  addRoom("yellowCourtyard", "Castle Fork", {
    neighbors: { north: "meadow", south: "swamp" },
    bgColor: "#201c2a"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, south: true } });
    room.castle = { color: "#e7d57f", accent: "#fff7b3", door: "east", label: "Yellow Castle", x: 260, y: 120, w: 380, h: 280 };
    room.walls = [];
    room.gate = new Gate(260 + 380/2 - 45, 120 + 280 - 130, 90, 120, {
      targetRoom: "yellowHall",
      targetDir: "west",
      targetEntry: { x: 110, y: H/2 - 36 },
      requiredKey: "key",
      open: false
    });
  });

  addRoom("yellowHall", "Golden Keep", {
    neighbors: { west: "yellowCourtyard" },
    entryPoints: { default: { x: 110, y: H/2 - 36 } },
    bgColor: "#3a2c15"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#9f7430", accent: "#ffe6a1", door: "east", label: "Keep", x: 200, y: 140, w: 520, h: 260 };
    room.walls.push(
      { x: 280, y: 160, w: 20, h: 280 },
      { x: 520, y: 140, w: 20, h: 320 }
    );
  });

  addRoom("woods", "Twisted Woods", {
    neighbors: { south: "meadow", east: "blackEntrance" },
    bgColor: "#111c11"
  }, (room) => {
    addBoundaryWalls(room, { open: { south: true, east: true } });
    room.walls.push(
      { x: 220, y: 80, w: 40, h: 440 },
      { x: 480, y: 40, w: 40, h: 520 }
    );
  });

  addRoom("blackEntrance", "Black Gate", {
    neighbors: { west: "woods", south: "riverbank", east: "blackHall" },
    bgColor: "#0f0f0f"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, south: true, east: true } });
    room.castle = { color: "#3a3a3a", accent: "#cfcfcf", door: "east", label: "Black Castle", x: 320, y: 140, w: 360, h: 260 };
    room.walls.push(
      { x: 320, y: 180, w: 20, h: 220 },
      { x: 600, y: 140, w: 20, h: 320 }
    );
  });

  addRoom("blackHall", "Shadow Hall", {
    neighbors: { west: "blackEntrance" },
    bgColor: "#1a1a1a"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#1f1f1f", accent: "#eeeeee", door: "east", label: "Dungeon", x: 240, y: 120, w: 520, h: 300 };
    room.walls.push(
      { x: 420, y: 100, w: 20, h: 360 }
    );
  });

  addRoom("riverbank", "River Switchbacks", {
    neighbors: { west: "meadow", north: "blackEntrance", south: "swamp", east: "greenMaze" },
    bgColor: "#0d1f30"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, north: true, south: true, east: true } });
    room.walls.push(
      { x: 200, y: 80, w: 20, h: 220 },
      { x: 480, y: 300, w: 20, h: 220 },
      { x: 340, y: 240, w: 200, h: 20 }
    );
  });

  addRoom("swamp", "Bog Crossing", {
    neighbors: { north: "yellowCourtyard", west: "riverbank", east: "greenEntrance", south: "dragonLair" },
    bgColor: "#1b281b"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, west: true, east: true, south: true } });
    room.walls.push(
      { x: 220, y: 120, w: 80, h: 200 },
      { x: 520, y: 280, w: 60, h: 200 }
    );
  });

  addRoom("greenMaze", "Tangled Maze", {
    neighbors: { west: "riverbank", south: "greenEntrance" },
    bgColor: "#123222"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, south: true } });
    room.walls.push(
      { x: 220, y: 80, w: 20, h: 420 },
      { x: 380, y: 80, w: 20, h: 420 },
      { x: 540, y: 80, w: 20, h: 420 }
    );
  });

  addRoom("greenEntrance", "Jade Gate", {
    neighbors: { west: "swamp", east: "greenHall", north: "greenMaze" },
    bgColor: "#1f321e"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true, north: true } });
    room.castle = { color: "#3f6633", accent: "#b9fb9c", door: "west", label: "Green Castle", x: 280, y: 160, w: 400, h: 240 };
    room.walls.push(
      { x: 280, y: 120, w: 20, h: 360 },
      { x: 560, y: 180, w: 20, h: 260 }
    );
  });

  addRoom("greenHall", "Emerald Hall", {
    neighbors: { west: "greenEntrance" },
    bgColor: "#294827"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#345b2c", accent: "#d5ffbd", door: "east", label: "Vault", x: 260, y: 140, w: 520, h: 260 };
    room.walls.push(
      { x: 360, y: 120, w: 20, h: 360 }
    );
  });

  addRoom("dragonLair", "Cavern Maw", {
    neighbors: { north: "swamp" },
    bgColor: "#2a0f12"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true } });
    room.walls.push(
      { x: 260, y: 100, w: 40, h: 360 },
      { x: 260, y: 100, w: 380, h: 40 },
      { x: 260, y: 420, w: 380, h: 40 }
    );
  });

  world.addItemToRoom(new Item("sword", 140, 120, 56, 20), "riverbank");
  world.addItemToRoom(new Item("key", 340, H/2 + 20, 40, 24), "yellowCourtyard");
  world.addItemToRoom(new Item("trophy", W - 260, H/2 - 24, 44, 36), "yellowHall");

  const dragon = new Dragon(80, H/2 - 32);
  world.rooms.dragonLair.enemies.push(dragon);

  world.currentRoomId = START_ROOM_ID;
}

function buildLabyrinthLayout(world) {
  world.rooms = {};
  const addRoom = createRoomAdder(world);

  addRoom("meadow", "Sunlit Field", {
    neighbors: { east: "riverbank", south: "mazeEntry" },
    entryPoints: { default: { x: 90, y: H/2 - 30 } },
    bgColor: "#1f301b"
  }, (room) => {
    addBoundaryWalls(room, { open: { east: true, south: true } });
    room.walls.push(
      { x: 260, y: 160, w: 20, h: 260 },
      { x: 520, y: 120, w: 20, h: 320 }
    );
  });

  addRoom("riverbank", "River Crossing", {
    neighbors: { west: "meadow", east: "yellowCourtyard", south: "swamp" },
    bgColor: "#0d2434"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true, south: true } });
    room.walls.push(
      { x: 220, y: 80, w: 20, h: 420 },
      { x: 480, y: 80, w: 20, h: 420 }
    );
  });

  addRoom("yellowCourtyard", "Citadel Approach", {
    neighbors: { west: "riverbank", east: "yellowHall" },
    bgColor: "#251f16"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
    room.castle = { color: "#f1d272", accent: "#fff2ad", door: "west", label: "Yellow Castle", x: 280, y: 100, w: 360, h: 300 };
    room.walls.push(
      { x: 300, y: 120, w: 20, h: 340 },
      { x: 520, y: 120, w: 20, h: 340 }
    );
  });

  addRoom("yellowHall", "Great Hall", {
    neighbors: { west: "yellowCourtyard" },
    entryPoints: { default: { x: 150, y: H/2 - 30 } },
    bgColor: "#3c2e1f"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#9f7d39", accent: "#ffe7a6", door: "east", label: "Throne", x: 200, y: 140, w: 520, h: 260 };
  });

  addRoom("mazeEntry", "Maze Gate", {
    neighbors: { north: "meadow", east: "mazeCenter" },
    bgColor: "#15221a"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true } });
    room.walls.push(
      { x: 320, y: 100, w: 20, h: 400 },
      { x: 500, y: 140, w: 20, h: 320 }
    );
  });

  addRoom("mazeCenter", "Inner Maze", {
    neighbors: { west: "mazeEntry", east: "blackEntrance", south: "greenMaze" },
    bgColor: "#0f1c11"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true, south: true } });
    room.walls.push(
      { x: 200, y: 60, w: 20, h: 360 },
      { x: 400, y: 180, w: 20, h: 360 },
      { x: 600, y: 80, w: 20, h: 360 },
      { x: 400, y: 60, w: 220, h: 20 }
    );
  });

  addRoom("blackEntrance", "Shadow Gate", {
    neighbors: { west: "mazeCenter", east: "blackHall" },
    bgColor: "#141414"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
    room.castle = { color: "#363636", accent: "#dedede", door: "west", label: "Black Castle", x: 300, y: 140, w: 380, h: 260 };
  });

  addRoom("blackHall", "Black Keep", {
    neighbors: { west: "blackEntrance" },
    bgColor: "#1f1f1f"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#252525", accent: "#f7f7f7", door: "east", label: "Vault", x: 220, y: 120, w: 520, h: 300 };
  });

  addRoom("greenMaze", "Lower Maze", {
    neighbors: { north: "mazeCenter", south: "greenEntrance" },
    bgColor: "#143021"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, south: true } });
    room.walls.push(
      { x: 240, y: 80, w: 20, h: 420 },
      { x: 460, y: 80, w: 20, h: 420 },
      { x: 680, y: 80, w: 20, h: 420 }
    );
  });

  addRoom("greenEntrance", "Emerald Gate", {
    neighbors: { north: "greenMaze", east: "greenHall" },
    bgColor: "#1f3a27"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true } });
    room.castle = { color: "#3f6b37", accent: "#d9febc", door: "north", label: "Green Castle", x: 280, y: 140, w: 400, h: 260 };
  });

  addRoom("greenHall", "Emerald Treasury", {
    neighbors: { west: "greenEntrance" },
    bgColor: "#28492f"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#345c31", accent: "#dbffb5", door: "east", label: "Treasure", x: 240, y: 120, w: 520, h: 300 };
  });

  addRoom("swamp", "Bog Lanes", {
    neighbors: { north: "riverbank", east: "dragonLair" },
    bgColor: "#1b2916"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true } });
    room.walls.push(
      { x: 200, y: 80, w: 120, h: 300 },
      { x: 520, y: 200, w: 160, h: 200 }
    );
  });

  addRoom("dragonLair", "Dragon Maw", {
    neighbors: { west: "swamp" },
    bgColor: "#2c1010"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.walls.push(
      { x: 220, y: 120, w: 20, h: 320 },
      { x: 220, y: 120, w: 420, h: 20 },
      { x: 220, y: 420, w: 420, h: 20 }
    );
  });

  world.addItemToRoom(new Item("sword", 260, 220, 64, 26), "mazeEntry");
  world.addItemToRoom(new Item("key", 320, H/2 + 30, 40, 24), "meadow");
  world.addItemToRoom(new Item("trophy", W - 280, H/2 - 26, 44, 36), "greenHall");

  const dragon = new Dragon(W - 260, H/2 - 32);
  world.rooms.dragonLair.enemies.push(dragon);

  world.currentRoomId = START_ROOM_ID;
}

function buildCatacombsLayout(world) {
  world.rooms = {};
  const addRoom = createRoomAdder(world);

  addRoom("meadow", "Clifftop Camp", {
    neighbors: { east: "ruins", south: "catGate" },
    entryPoints: { default: { x: 80, y: H/2 - 24 } },
    bgColor: "#1d2316"
  }, (room) => {
    addBoundaryWalls(room, { open: { east: true, south: true } });
    room.pedestal = { x: 48, y: H/2 - 26, w: 110, h: 20 };
  });

  addRoom("ruins", "Overgrown Ruins", {
    neighbors: { west: "meadow", east: "riverWatch", south: "boneYard" },
    bgColor: "#262c1c"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true, south: true } });
    room.walls.push(
      { x: 220, y: 80, w: 20, h: 360 },
      { x: 460, y: 120, w: 20, h: 320 }
    );
  });

  addRoom("riverWatch", "River Watch", {
    neighbors: { west: "ruins", east: "yellowCourtyard", south: "marsh" },
    bgColor: "#132029"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true, south: true } });
    room.walls.push(
      { x: 160, y: 80, w: 20, h: 420 },
      { x: 520, y: 80, w: 20, h: 420 }
    );
  });

  addRoom("yellowCourtyard", "Sunken Yellow Gate", {
    neighbors: { west: "riverWatch" },
    bgColor: "#30251b"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#f4d26a", accent: "#fff2a1", roof: "#b98b41", door: "west", label: "Yellow Castle", x: 300, y: 120, w: 340, h: 260 };
    room.walls = [];
    room.gate = new Gate(300 + 340/2 - 45, 120 + 260 - 130, 90, 120, {
      targetRoom: "yellowHall",
      targetDir: "west",
      targetEntry: { x: 120, y: H/2 - 36 },
      requiredKey: "key",
      open: false
    });
  });

  addRoom("yellowHall", "Golden Treasury", {
    neighbors: { west: "yellowCourtyard" },
    entryPoints: { default: { x: 120, y: H/2 - 36 } },
    bgColor: "#3a2b1a"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#a77c38", accent: "#ffe3a4", roof: "#7c5221", door: "east", label: "Throne", x: 220, y: 140, w: 500, h: 260 };
  });

  addRoom("catGate", "Catacomb Gate", {
    neighbors: { north: "meadow", south: "catHall" },
    bgColor: "#1a1c21"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, south: true } });
    room.walls.push(
      { x: 360, y: 80, w: 20, h: 420 }
    );
    room.castle = { color: "#4a4d56", accent: "#c7cdd9", door: "south", label: "Catacombs", x: 200, y: 160, w: 360, h: 220 };
  });

  addRoom("catHall", "Catacomb Hall", {
    neighbors: { north: "catGate", east: "catCross", west: "catArchive" },
    bgColor: "#101219"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true, west: true } });
    room.walls.push(
      { x: 300, y: 140, w: 20, h: 320 },
      { x: 520, y: 80, w: 20, h: 420 }
    );
  });

  addRoom("catArchive", "Silent Archive", {
    neighbors: { east: "catHall", south: "crypt" },
    bgColor: "#161820"
  }, (room) => {
    addBoundaryWalls(room, { open: { east: true, south: true } });
  });

  addRoom("crypt", "Deep Crypt", {
    neighbors: { north: "catArchive", south: "catVault" },
    bgColor: "#13121a"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, south: true } });
    room.walls.push(
      { x: 360, y: 60, w: 20, h: 460 }
    );
  });

  addRoom("catVault", "Vault of Bones", {
    neighbors: { north: "crypt" },
    bgColor: "#0f0f15"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true } });
  });

  addRoom("catCross", "Catacomb Crossroads", {
    neighbors: { west: "catHall", east: "greenEntrance", south: "lavaTunnel" },
    bgColor: "#15161d"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true, south: true } });
  });

  addRoom("lavaTunnel", "Lava Tunnel", {
    neighbors: { north: "catCross", south: "dragonDen" },
    bgColor: "#2b0d0d"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, south: true } });
    room.walls.push(
      { x: 360, y: 80, w: 20, h: 420 }
    );
  });

  addRoom("dragonDen", "Dragon Den", {
    neighbors: { north: "lavaTunnel", west: "boneYard", east: "greenEntrance" },
    bgColor: "#300e0e"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, west: true, east: true } });
  });

  addRoom("boneYard", "Bone Yard", {
    neighbors: { north: "ruins", east: "dragonDen" },
    bgColor: "#27180f"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true } });
  });

  addRoom("marsh", "Weeping Marsh", {
    neighbors: { north: "riverWatch", east: "blackEntrance", south: "obsidianPass" },
    bgColor: "#132119"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true, south: true } });
  });

  addRoom("obsidianPass", "Obsidian Pass", {
    neighbors: { north: "marsh", south: "blackHall" },
    bgColor: "#1f141c"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, south: true } });
  });

  addRoom("blackEntrance", "Black Gate", {
    neighbors: { west: "marsh", east: "blackHall" },
    bgColor: "#0f0f0f"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
    room.castle = { color: "#3a3a3a", accent: "#cfcfcf", roof: "#222", door: "west", label: "Black Castle", x: 320, y: 140, w: 360, h: 260 };
  });

  addRoom("blackHall", "Shadow Keep", {
    neighbors: { west: "blackEntrance" },
    bgColor: "#1c1c1c"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#272727", accent: "#f5f5f5", roof: "#555", door: "east", label: "Dungeon", x: 240, y: 120, w: 500, h: 280 };
  });

  addRoom("greenEntrance", "Green Gate", {
    neighbors: { west: "catCross", east: "greenHall" },
    bgColor: "#18321b"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
    room.gate = new Gate(W/2 - 45, H/2 - 60, 90, 120, {
      targetRoom: "greenHall",
      targetDir: "west",
      targetEntry: { x: 140, y: H/2 - 30 },
      requiredKey: "key",
      open: true
    });
    room.castle = { color: "#466b3d", accent: "#c4f0ad", roof: "#2d4e29", door: "west", label: "Green Castle", x: 300, y: 150, w: 360, h: 240 };
  });

  addRoom("greenHall", "Emerald Vault", {
    neighbors: { west: "greenEntrance" },
    bgColor: "#234026",
    entryPoints: { west: { x: 140, y: H/2 - 30 }, default: { x: 140, y: H/2 - 30 } }
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#33522f", accent: "#d4ffbf", roof: "#1f311f", door: "east", label: "Vault", x: 240, y: 140, w: 500, h: 260 };
  });

  world.addItemToRoom(new Item("sword", 160, H/2 - 18, 60, 26), "ruins");
  world.addItemToRoom(new Item("key", W/2 - 20, H/2 - 10, 40, 26), "catVault");
  world.addItemToRoom(new Item("trophy", W - 260, H/2 - 24, 44, 36), "greenHall");

  const dragonA = new Dragon(W - 260, H/2 - 40);
  const dragonB = new Dragon(200, 240);
  world.rooms.dragonDen.enemies.push(dragonA);
  world.rooms.marsh.enemies.push(dragonB);

  world.currentRoomId = START_ROOM_ID;
}

function buildHighlandsLayout(world) {
  world.rooms = {};
  const addRoom = createRoomAdder(world);

  addRoom("meadow", "Highland Meadow", {
    neighbors: { east: "ridge", south: "forest" },
    entryPoints: { default: { x: 80, y: H/2 - 24 } },
    bgColor: "#1c2a1a"
  }, (room) => {
    addBoundaryWalls(room, { open: { east: true, south: true } });
    room.pedestal = { x: 60, y: H/2 - 24, w: 120, h: 20 };
  });

  addRoom("ridge", "Windy Ridge", {
    neighbors: { west: "meadow", east: "yellowCourtyard", south: "lakePass" },
    bgColor: "#222f1f"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true, south: true } });
  });

  addRoom("forest", "Pine Forest", {
    neighbors: { north: "meadow", east: "lakePass", south: "swamp" },
    bgColor: "#152417"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true, south: true } });
  });

  addRoom("lakePass", "Lake Pass", {
    neighbors: { north: "ridge", west: "forest", east: "greenEntrance", south: "cavernMouth" },
    bgColor: "#0f2331"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, west: true, east: true, south: true } });
  });

  addRoom("yellowCourtyard", "Yellow Outpost", {
    neighbors: { west: "ridge", south: "cliffRoad" },
    bgColor: "#302615"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, south: true } });
    room.castle = { color: "#f2d37b", accent: "#fff6b0", roof: "#b9853f", door: "west", label: "Yellow Castle", x: 300, y: 110, w: 360, h: 260 };
    room.walls = [];
    room.gate = new Gate(300 + 360/2 - 45, 110 + 260 - 130, 90, 120, {
      targetRoom: "yellowHall",
      targetDir: "west",
      targetEntry: { x: 120, y: H/2 - 40 },
      requiredKey: "key",
      open: false
    });
  });

  addRoom("yellowHall", "Golden Hall", {
    neighbors: { west: "yellowCourtyard" },
    bgColor: "#3a2c17"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#9d7634", accent: "#ffe5a2", roof: "#734d1d", door: "east", label: "Throne", x: 220, y: 140, w: 520, h: 260 };
  });

  addRoom("cliffRoad", "Cliff Road", {
    neighbors: { north: "yellowCourtyard", east: "cavernMouth", south: "coast" },
    bgColor: "#1e1f29"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true, south: true } });
  });

  addRoom("coast", "Rocky Coast", {
    neighbors: { north: "cliffRoad", east: "harbor" },
    bgColor: "#0f1b29"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true } });
  });

  addRoom("harbor", "Abandoned Harbor", {
    neighbors: { west: "coast" },
    bgColor: "#102031"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
  });

  addRoom("swamp", "Sunken Swamp", {
    neighbors: { north: "forest", east: "blackEntrance", south: "bogDepths" },
    bgColor: "#152515"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true, south: true } });
  });

  addRoom("bogDepths", "Bog Depths", {
    neighbors: { north: "swamp", east: "blackEntrance" },
    bgColor: "#101e10"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true } });
  });

  addRoom("blackEntrance", "Black Rampart", {
    neighbors: { west: "swamp", east: "blackHall" },
    bgColor: "#101010"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
    room.castle = { color: "#3c3c3c", accent: "#cfcfcf", roof: "#202020", door: "west", label: "Black Castle", x: 320, y: 140, w: 360, h: 260 };
    room.gate = new Gate(W/2 - 45, H/2 - 60, 90, 120, {
      targetRoom: "blackHall",
      targetDir: "west",
      targetEntry: { x: 140, y: H/2 - 30 },
      requiredKey: "key",
      open: false
    });
  });

  addRoom("blackHall", "Shadow Citadel", {
    neighbors: { west: "blackEntrance" },
    bgColor: "#1f1f1f"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#2a2a2a", accent: "#f2f2f2", roof: "#555", door: "east", label: "Dungeon", x: 240, y: 120, w: 520, h: 280 };
  });

  addRoom("greenEntrance", "Green Spire Gate", {
    neighbors: { west: "lakePass", east: "greenHall" },
    bgColor: "#17311b"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
    room.gate = new Gate(W/2 - 45, H/2 - 60, 90, 120, {
      targetRoom: "greenHall",
      targetDir: "west",
      targetEntry: { x: 140, y: H/2 - 28 },
      requiredKey: "key",
      open: true
    });
    room.castle = { color: "#436c38", accent: "#d2feb8", roof: "#264627", door: "west", label: "Green Castle", x: 300, y: 140, w: 360, h: 240 };
  });

  addRoom("greenHall", "Emerald Hall", {
    neighbors: { west: "greenEntrance" },
    bgColor: "#224428",
    entryPoints: { west: { x: 140, y: H/2 - 28 }, default: { x: 140, y: H/2 - 28 } }
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#33542f", accent: "#dcffbe", roof: "#223122", door: "east", label: "Vault", x: 260, y: 140, w: 520, h: 260 };
  });

  addRoom("cavernMouth", "Cavern Mouth", {
    neighbors: { north: "lakePass", east: "cavernDepths", south: "dragonLair", west: "cliffRoad" },
    bgColor: "#1a1b27"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true, south: true, west: true } });
  });

  addRoom("cavernDepths", "Cavern Depths", {
    neighbors: { west: "cavernMouth", east: "towerGate", south: "lavaSea" },
    bgColor: "#191728"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true, south: true } });
  });

  addRoom("towerGate", "Sky Tower Gate", {
    neighbors: { west: "cavernDepths", east: "towerTop" },
    bgColor: "#202138"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
    room.castle = { color: "#5364a3", accent: "#d5deff", roof: "#2c366b", towers: 1, door: "east", label: "Sky Tower", x: 300, y: 90, w: 360, h: 300 };
  });

  addRoom("towerTop", "Sky Tower", {
    neighbors: { west: "towerGate" },
    bgColor: "#2a2f46"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
  });

  addRoom("lavaSea", "Lava Sea", {
    neighbors: { north: "cavernDepths", south: "gauntletHall" },
    bgColor: "#330f0f"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, south: true } });
  });

  addRoom("gauntletHall", "Inferno Gauntlet", {
    neighbors: { north: "lavaSea" },
    bgColor: "#3a0d0d"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true } });
  });

  addRoom("dragonLair", "Dragon Lair", {
    neighbors: { north: "cavernMouth" },
    bgColor: "#311010"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true } });
  });

  world.addItemToRoom(new Item("sword", 200, H/2 - 16, 60, 24), "ridge");
  world.addItemToRoom(new Item("key", W - 220, H/2 - 20, 40, 24), "blackHall");
  world.addItemToRoom(new Item("trophy", W - 240, H/2 - 24, 44, 36), "towerTop");

  const dragonHigh = new Dragon(240, H/2 - 40);
  const dragonLow = new Dragon(W - 220, 200);
  world.rooms.dragonLair.enemies.push(dragonHigh);
  world.rooms.swamp.enemies.push(dragonLow);

  world.currentRoomId = START_ROOM_ID;
}

function buildGauntletLayout(world) {
  world.rooms = {};
  const addRoom = createRoomAdder(world);

  addRoom("meadow", "Frontier Camp", {
    neighbors: { east: "fields", south: "tangle" },
    entryPoints: { default: { x: 84, y: H/2 - 24 } },
    bgColor: "#202418"
  }, (room) => {
    addBoundaryWalls(room, { open: { east: true, south: true } });
    room.pedestal = { x: 60, y: H/2 - 24, w: 120, h: 20 };
  });

  addRoom("fields", "Rolling Fields", {
    neighbors: { west: "meadow", east: "fortGate", south: "riverSouth" },
    bgColor: "#27311d"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true, south: true } });
  });

  addRoom("fortGate", "Fortress Gate", {
    neighbors: { west: "fields", east: "fortHall", south: "cliffPass" },
    bgColor: "#2f261d"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true, south: true } });
    room.castle = { color: "#e4c36d", accent: "#fff4ab", roof: "#b07c36", door: "west", label: "Fortress", x: 320, y: 110, w: 360, h: 260 };
    room.gate = new Gate(W/2 - 45, H/2 - 60, 90, 120, {
      targetRoom: "fortHall",
      targetDir: "west",
      targetEntry: { x: 120, y: H/2 - 40 },
      requiredKey: "key",
      open: false
    });
  });

  addRoom("fortHall", "Fortress Hall", {
    neighbors: { west: "fortGate", east: "towerHall" },
    bgColor: "#3b2b1f"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
  });

  addRoom("towerHall", "Tower Hall", {
    neighbors: { west: "fortHall" },
    bgColor: "#322c3d"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#4d5f9a", accent: "#dbe4ff", roof: "#273469", door: "east", label: "Sky Tower", x: 260, y: 100, w: 460, h: 300 };
  });

  addRoom("tangle", "Thorn Tangle", {
    neighbors: { north: "meadow", east: "riverSouth", south: "shadowGlade" },
    bgColor: "#162116"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true, south: true } });
  });

  addRoom("riverSouth", "Southern River", {
    neighbors: { north: "fields", west: "tangle", east: "greenEntrance", south: "delta" },
    bgColor: "#102333"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, west: true, east: true, south: true } });
  });

  addRoom("delta", "Delta Flats", {
    neighbors: { north: "riverSouth", east: "obsidianGate" },
    bgColor: "#122223"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true } });
  });

  addRoom("obsidianGate", "Obsidian Gate", {
    neighbors: { west: "delta", east: "obsidianHall" },
    bgColor: "#111015"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
    room.castle = { color: "#3a3a3a", accent: "#dedede", roof: "#232323", door: "west", label: "Black Castle", x: 320, y: 140, w: 360, h: 260 };
  });

  addRoom("obsidianHall", "Obsidian Hall", {
    neighbors: { west: "obsidianGate" },
    bgColor: "#1c1c1c"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
  });

  addRoom("shadowGlade", "Shadow Glade", {
    neighbors: { north: "tangle", east: "marshEast", south: "dragonAerie" },
    bgColor: "#101b13"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true, south: true } });
  });

  addRoom("marshEast", "Eastern Marsh", {
    neighbors: { west: "shadowGlade", east: "blackEntrance", south: "catacombGate" },
    bgColor: "#162616"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true, south: true } });
  });

  addRoom("blackEntrance", "Black Fortress Gate", {
    neighbors: { west: "marshEast", east: "blackHall" },
    bgColor: "#0f0f0f"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
    room.castle = { color: "#404040", accent: "#dcdcdc", roof: "#242424", door: "west", label: "Black Fortress", x: 320, y: 140, w: 360, h: 260 };
    room.gate = new Gate(W/2 - 45, H/2 - 60, 90, 120, {
      targetRoom: "blackHall",
      targetDir: "west",
      targetEntry: { x: 140, y: H/2 - 30 },
      requiredKey: "key",
      open: false
    });
  });

  addRoom("blackHall", "Black Fortress", {
    neighbors: { west: "blackEntrance" },
    bgColor: "#1d1d1d"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
  });

  addRoom("catacombGate", "Catacomb Gate", {
    neighbors: { north: "marshEast", south: "catacombDepths" },
    bgColor: "#161219"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, south: true } });
  });

  addRoom("catacombDepths", "Depths", {
    neighbors: { north: "catacombGate", east: "lavaBridge" },
    bgColor: "#141018"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true } });
  });

  addRoom("lavaBridge", "Lava Bridge", {
    neighbors: { west: "catacombDepths", east: "dragonAerie" },
    bgColor: "#2f0c0c"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
  });

  addRoom("dragonAerie", "Dragon Aerie", {
    neighbors: { north: "shadowGlade", west: "lavaBridge", east: "towerHall" },
    bgColor: "#330f0f"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, west: true, east: true } });
  });

  addRoom("greenEntrance", "Verdant Gate", {
    neighbors: { west: "riverSouth", east: "greenHall" },
    bgColor: "#163018"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
    room.castle = { color: "#3f6534", accent: "#c6f7b2", roof: "#274326", door: "west", label: "Green Castle", x: 300, y: 150, w: 360, h: 240 };
    room.gate = new Gate(W/2 - 45, H/2 - 60, 90, 120, {
      targetRoom: "greenHall",
      targetDir: "west",
      targetEntry: { x: 140, y: H/2 - 30 },
      requiredKey: "key",
      open: true
    });
  });

  addRoom("greenHall", "Verdant Hall", {
    neighbors: { west: "greenEntrance" },
    bgColor: "#214224",
    entryPoints: { west: { x: 140, y: H/2 - 30 }, default: { x: 140, y: H/2 - 30 } }
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
  });

  world.addItemToRoom(new Item("sword", 220, H/2 - 18, 60, 24), "fields");
  world.addItemToRoom(new Item("key", W - 220, H/2 - 20, 40, 24), "obsidianHall");
  world.addItemToRoom(new Item("trophy", W - 240, H/2 - 26, 44, 36), "towerHall");

  const dragonOne = new Dragon(W - 280, 180);
  const dragonTwo = new Dragon(200, H/2 - 32);
  world.rooms.dragonAerie.enemies.push(dragonOne);
  world.rooms.delta.enemies.push(dragonTwo);

  world.currentRoomId = START_ROOM_ID;
}

const state = {
  paused: false,
  winTimer: 0
};

/* =========================================================
   Input edge detection (pressed once)
   ========================================================= */

const _pressed = new Set();
addEventListener("keydown", (e) => {
  const k = e.key.toLowerCase();
  if (!_pressed.has(k)) _pressed.add(k);
});
function wasPressed(k) {
  k = k.toLowerCase();
  if (_pressed.has(k)) { _pressed.delete(k); return true; }
  return false;
}

const _touchActions = { interact: false, drop: false };
function touchActionPressed(action) {
  if (_touchActions[action]) {
    _touchActions[action] = false;
    return true;
  }
  return false;
}

/* =========================================================
   Game loop
   ========================================================= */

let last = 0;
function perfNow(){ return performance.now(); }

function loop(ts) {
  const dt = Math.min(0.033, (ts - last) / 1000);
  last = ts;

  // toggles
  if (wasPressed("p")) { state.paused = !state.paused; showToast(state.paused ? "Paused" : "Resumed"); }
  if (wasPressed("r")) { WORLD.resetAll(); showToast("Reset"); }

  if (!state.paused) {
    WORLD.update(dt);
    if (state.winTimer > 0) {
      state.winTimer += dt;
    }
  }

  // draw
  WORLD.draw();

  // HUD
  renderHUD();

  // win banner
  if (state.winTimer > 0) {
    ctx.fillStyle = "rgba(0,0,0,.55)";
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = "#e8eef8";
    ctx.font = "bold 42px system-ui, sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("You Win!", W/2, H/2 - 20);
    ctx.font = "16px system-ui, sans-serif";
    ctx.fillStyle = "#aab4c0";
    ctx.fillText("Press R to play again", W/2, H/2 + 24);
  }

  requestAnimationFrame(loop);
}

function renderHUD() {
  const hud = document.getElementById("hud");
  hud.innerHTML = "";
  const tag = (t)=>{ const el=document.createElement("div"); el.className="tag"; el.textContent=t; return el; };
  hud.append(tag(`Level: ${activeLevelName}`));
  hud.append(tag(`Kid: ${activeKidName}`));
  if (WORLD.currentLayoutName) {
    hud.append(tag(`Layout: ${WORLD.currentLayoutName}`));
  }
  hud.append(tag(`Room: ${WORLD.current().name}`));
  if (WORLD.player.holding) hud.append(tag(`Holding: ${WORLD.player.holding.kind}`));
  if (WORLD.current().gate) hud.append(tag(`Gate: ${WORLD.current().gate.open ? "Open" : "Closed"}`));
}

/* =========================================================
   Buttons
   ========================================================= */

document.getElementById("btnReset").addEventListener("click", ()=>{ WORLD.resetAll(); showToast("Reset"); });
document.getElementById("btnPause").addEventListener("click", ()=>{ state.paused=!state.paused; showToast(state.paused ? "Paused" : "Resumed"); });

function setupTouchControls() {
  const pad = document.getElementById("touchPad");
  if (!pad) return;
  const startDir = (dir) => { touchState[dir] = true; };
  const stopDir = (dir) => { touchState[dir] = false; };

  pad.querySelectorAll("[data-dir]").forEach(btn => {
    const dir = btn.getAttribute("data-dir");
    const start = (ev) => {
      ev.preventDefault();
      startDir(dir);
    };
    const end = (ev) => {
      ev.preventDefault();
      stopDir(dir);
    };
    btn.addEventListener("touchstart", start);
    btn.addEventListener("mousedown", start);
    btn.addEventListener("touchend", end);
    btn.addEventListener("touchcancel", end);
    btn.addEventListener("mouseup", end);
    btn.addEventListener("mouseleave", end);
  });

  document.querySelectorAll(".touch-actions .touch-btn").forEach(btn => {
    const action = btn.dataset.action;
    btn.addEventListener("click", (ev) => {
      ev.preventDefault();
      _touchActions[action] = true;
    });
    btn.addEventListener("touchstart", (ev) => {
      ev.preventDefault();
      _touchActions[action] = true;
    });
  });
}

/* =========================================================
   Start
   ========================================================= */

WORLD.resetAll();
setupTouchControls();
requestAnimationFrame((t)=>{ last=t; requestAnimationFrame(loop); });
</script>
</body>
</html>
