<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Adventure-like (HTML5 Canvas) — Custom Characters</title>
<style>
  :root {
    --bg: #0f1115;
    --panel: #151a21;
    --ink: #e8eef8;
    --muted: #aab4c0;
    --accent: #5fd4ff;
    --accent-2: #89ffa3;
  }
  * { box-sizing: border-box; }
  html, body { height: 100%; background: var(--bg); color: var(--ink); font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif; }
  body { margin: 0; display: grid; grid-template-columns: 320px 1fr; gap: 0; min-height: 100vh; }
  aside {
    background: var(--panel);
    border-right: 1px solid #1f2630;
    padding: 18px 16px 24px;
    overflow: auto;
  }
  h1 { font-size: 16px; margin: 0 0 12px; font-weight: 600; letter-spacing: .2px; }
  h2 { font-size: 12px; margin: 18px 0 10px; text-transform: uppercase; color: var(--muted); letter-spacing: .7px; }
  .row { display: grid; grid-template-columns: 1fr; gap: 8px; margin-bottom: 12px; }
  label { font-size: 13px; color: var(--muted); }
  input[type="file"] {
    width: 100%;
    padding: 8px;
    background: #0e1318;
    border: 1px solid #1f2630;
    color: var(--ink);
    border-radius: 8px;
  }
  button {
    appearance: none; border: 1px solid #1f2630;
    background: #0e1318; color: var(--ink);
    padding: 10px 12px; border-radius: 8px; cursor: pointer;
    font-weight: 600; font-size: 14px;
  }
  button:hover { border-color: #2a3240; }
  .btns { display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 8px; }
  .touch-controls {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(3, 1fr);
    gap: 8px;
    max-width: 200px;
    margin: 16px auto 0;
    touch-action: none;
  }
  .touch-btn {
    min-height: 54px;
    border-radius: 12px;
    border: 1px solid #2a3240;
    background: rgba(12,17,22,.8);
    color: var(--ink);
    font-weight: 600;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
  }
  .touch-btn:active {
    background: rgba(95,212,255,.35);
    border-color: var(--accent);
  }
  .touch-pad {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(3, 1fr);
    gap: 6px;
  }
  .touch-pad .touch-btn {
    min-height: 48px;
    font-size: 18px;
  }
  .touch-actions {
    display: grid;
    grid-template-columns: repeat(2, minmax(0,1fr));
    gap: 8px;
    margin-top: 12px;
  }
  .kbd {
    display: inline-block; padding: 2px 6px; border: 1px solid #2a3240;
    border-bottom-width: 2px; border-radius: 6px; background: #0d1217; font-size: 12px; color: var(--ink);
  }
  .tips { font-size: 13px; color: var(--muted); line-height: 1.4; }
  main { display: grid; place-items: center; padding: 12px; }
  canvas {
    width: min(100%, 960px); height: auto; background: #0b0e13; border: 1px solid #1f2630; border-radius: 12px;
    box-shadow: 0 0 0 1px #0b0e13, 0 6px 30px rgba(0,0,0,.45);
  }
  .hud {
    position: absolute; inset: 12px 12px auto auto; pointer-events: none;
    display: flex; gap: 8px; flex-wrap: wrap; font-size: 12px; color: var(--muted);
  }
  .tag {
    padding: 4px 8px; border: 1px solid #2a3240; border-radius: 999px; background: rgba(17,22,29,.72); backdrop-filter: blur(6px);
  }
  .toast {
    position: absolute; left: 50%; transform: translateX(-50%);
    bottom: 18px; background: rgba(17,22,29,.9); color: var(--ink);
    border: 1px solid #2a3240; padding: 10px 14px; border-radius: 10px; font-size: 14px;
    display: none;
  }
  .toast.show { display: block; }
  @media (max-width: 900px) {
    body {
      grid-template-columns: 1fr;
      grid-template-rows: auto auto;
    }
    main {
      order: 1;
    }
    aside {
      order: 2;
      border-right: none;
      border-top: 1px solid #1f2630;
    }
    canvas {
      width: 100%;
    }
  }
  @media (max-width: 600px) {
    .btns, .touch-actions { grid-template-columns: 1fr; }
    .touch-controls { margin-top: 8px; }
  }
</style>
</head>
<body>
  <aside>
    <h1 id="gameTitle">Kid Adventure</h1>
    <div class="row tips">
      Carry one item at a time. Grab the <b>sword</b> to fight dragons, use the <b>bridge</b> to pass through walls, and match <b>colored keys</b> to their gates. The white key opens any gate. Return the <b>trophy</b> to the start pedestal to win.
    </div>
    <h2>How to Play</h2>
    <div class="row tips">
      <b>1.</b> Find the sword and bridge near the start routes.<br>
      <b>2.</b> Match yellow, black, and green keys to their gates (white key opens any gate).<br>
      <b>3.</b> The bat steals items and drops them in other rooms.<br>
      <b>4.</b> Defeat dragons with the sword, then bring the trophy home.<br>
      Gates, dragons, and treasures move around depending on the level you pick.
    </div>

    <div class="row">
      <label for="kidSelect">Choose adventurer</label>
      <select id="kidSelect"></select>
    </div>
    <div class="tips">
      Switching heroes reloads their art instantly and respawns you near the start.
    </div>
    <div class="row">
      <label for="levelSelect">Choose level</label>
      <select id="levelSelect"></select>
    </div>
    <div class="tips">
      Level 1 is the classic grounds, Level 2 adds sprawling catacombs, Level 3 is a huge dragon gauntlet.
    </div>

    <h2>Game</h2>
    <div class="btns">
      <button id="btnReset">Reset (R)</button>
      <button id="btnPause">Pause (P)</button>
    </div>

    <h2>Touch Controls</h2>
    <div class="touch-pad" id="touchPad">
      <div></div>
      <button class="touch-btn" data-dir="up">▲</button>
      <div></div>
      <button class="touch-btn" data-dir="left">◀</button>
      <div></div>
      <button class="touch-btn" data-dir="right">▶</button>
      <div></div>
      <button class="touch-btn" data-dir="down">▼</button>
      <div></div>
    </div>
    <div class="touch-actions">
      <button class="touch-btn" data-action="interact">Use / Pick (E)</button>
      <button class="touch-btn" data-action="drop">Drop (Q)</button>
    </div>

    <h2>Controls</h2>
    <div class="tips">
      Move: <span class="kbd">WASD</span> / <span class="kbd">Arrows</span><br>
      Pick up / Use: <span class="kbd">E</span> &nbsp;·&nbsp; Drop: <span class="kbd">Q</span><br>
    </div>

    <h2>Notes</h2>
    <div class="tips">
      Images are scaled to the entity size after loading from disk. Update the PNGs
      in each kid folder and refresh to see them in game. Transparent backgrounds look best.
      Each reset rotates through curated map variants so the overworld layout always changes
      but stays solvable.
    </div>
  </aside>

  <main>
    <div class="hud" id="hud"></div>
    <canvas id="game" width="960" height="600"></canvas>
    <div class="toast" id="toast"></div>
  </main>

<script>
"use strict";

/* =========================================================
   Basic engine + game objects
   ========================================================= */

const W = 960, H = 600;
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d", { alpha: false });
ctx.imageSmoothingEnabled = false;

const keys = new Set();
const held = (k) => keys.has(k);
const KEY_CAPTURE_TAGS = new Set(["INPUT", "SELECT", "TEXTAREA", "BUTTON"]);
const PREVENT_KEYS = new Set(["arrowup", "arrowdown", "arrowleft", "arrowright", " "]);
function shouldCaptureKey(e) {
  const tag = e.target?.tagName;
  return !tag || !KEY_CAPTURE_TAGS.has(tag);
}
addEventListener("keydown", (e) => {
  if (!shouldCaptureKey(e)) return;
  const key = e.key.toLowerCase();
  if (PREVENT_KEYS.has(key)) e.preventDefault();
  keys.add(key);
});
addEventListener("keyup", (e) => {
  if (!shouldCaptureKey(e)) return;
  const key = e.key.toLowerCase();
  if (PREVENT_KEYS.has(key)) e.preventDefault();
  keys.delete(key);
});

const touchState = {
  up: false,
  down: false,
  left: false,
  right: false
};

function heldDirection(dir) {
  if (touchState[dir]) return true;
  if (dir === "up") return held("arrowup") || held("w");
  if (dir === "down") return held("arrowdown") || held("s");
  if (dir === "left") return held("arrowleft") || held("a");
  if (dir === "right") return held("arrowright") || held("d");
  return false;
}

function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
function resolveItemGateOverlap(item, room, player) {
  if (!room.gate || room.gate.open) return;
  const g = room.gate.rect;
  if (!rectsOverlap(item, g)) return;
  // Nudge item to the side away from the gate so it remains reachable
  if (player.x < g.x) {
    item.x = clamp(g.x - item.w - 6, 8, W - item.w - 8);
  } else {
    item.x = clamp(g.x + g.w + 6, 8, W - item.w - 8);
  }
  item.y = clamp(item.y, 8, H - item.h - 8);
}
function rectsTouchOrOverlap(a, b, pad=0) {
  // Inclusive edges so the player touching the gate can still trigger it
  return (
    a.x - pad <= b.x + b.w &&
    a.x + a.w + pad >= b.x &&
    a.y - pad <= b.y + b.h &&
    a.y + a.h + pad >= b.y
  );
}
function rectsOverlap(a, b) {
  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}
function drawRect(r, color="#fff") {
  ctx.fillStyle = color; ctx.fillRect(r.x, r.y, r.w, r.h);
}
function outlineRect(r, color="#fff") {
  ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.strokeRect(r.x+1, r.y+1, r.w-2, r.h-2);
}
function drawWallRect(r, color="#2a3340", stroke="#11161d") {
  const grad = ctx.createLinearGradient(r.x, r.y, r.x, r.y + r.h);
  grad.addColorStop(0, color);
  grad.addColorStop(1, "#1b222c");
  ctx.fillStyle = grad;
  ctx.fillRect(r.x, r.y, r.w, r.h);
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 2;
  ctx.strokeRect(r.x + 1, r.y + 1, r.w - 2, r.h - 2);
}
function drawImageOrFallback(img, r, color, label) {
  if (img && img.complete && img.naturalWidth > 0) {
    const imgRatio = img.naturalWidth / img.naturalHeight;
    const rectRatio = r.w / r.h;
    let dw, dh;
    if (imgRatio > rectRatio) {
      dw = r.w;
      dh = dw / imgRatio;
    } else {
      dh = r.h;
      dw = dh * imgRatio;
    }
    const dx = r.x + (r.w - dw) / 2;
    const dy = r.y + (r.h - dh) / 2;
    ctx.drawImage(img, dx|0, dy|0, dw|0, dh|0);
  } else {
    drawRect(r, color);
    if (label) {
      ctx.fillStyle = "rgba(0,0,0,.7)";
      ctx.font = "bold 12px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(label, r.x + r.w/2, r.y + r.h/2);
    }
  }
}
function showToast(text, ms=1600) {
  const t = document.getElementById("toast");
  t.textContent = text;
  t.classList.add("show");
  clearTimeout(showToast._id);
  showToast._id = setTimeout(()=>t.classList.remove("show"), ms);
}

function drawCastleSilhouette(cfg={}) {
  const {
    color = "#d8c16f",
    outline = "#3b3523",
    accent = "#f7e69b",
    roof = "#a67c3e",
    towers = 2,
    door = "west",
    label = "",
    x = 220,
    y = 80,
    w = 520,
    h = 360
  } = cfg;

  const towerWidth = Math.min(70, w * 0.15);
  const towerHeight = h + 40;
  ctx.fillStyle = color;
  ctx.fillRect(x, y, w, h);
  ctx.strokeStyle = outline;
  ctx.lineWidth = 4;
  ctx.strokeRect(x, y, w, h);

  for (let i=0; i<towers; i++) {
    const offset = Math.min(30, towerWidth * 0.6);
    const tx = i === 0 ? x - offset : x + w - towerWidth + offset/2;
    ctx.fillStyle = color;
    ctx.fillRect(tx, y - 10, towerWidth, towerHeight);
    ctx.strokeRect(tx, y - 10, towerWidth, towerHeight);
    ctx.fillStyle = roof;
    ctx.beginPath();
    ctx.moveTo(tx - 10, y - 10);
    ctx.lineTo(tx + towerWidth/2, y - 60);
    ctx.lineTo(tx + towerWidth + 10, y - 10);
    ctx.closePath();
    ctx.fill();
  }

  const crenelCount = Math.floor(w / 40);
  for (let i=0; i<crenelCount; i++) {
    const span = w / crenelCount;
    ctx.fillStyle = accent;
    ctx.fillRect(x + i*span + 6, y - 18, span - 12, 18);
    ctx.strokeRect(x + i*span + 6, y - 18, span - 12, 18);
  }

  const windowCount = Math.max(2, Math.floor(w / 120));
  const windowW = 24, windowH = 36;
  ctx.fillStyle = "rgba(0,0,0,0.45)";
  for (let i=0; i<windowCount; i++) {
    const wx = x + (i+1) * (w/(windowCount+1)) - windowW/2;
    const wy = y + h/3;
    ctx.fillRect(wx, wy, windowW, windowH);
    ctx.fillRect(wx, wy + 80, windowW, windowH);
  }

  const doorW = 90, doorH = 130;
  let doorX = x + w/2 - doorW/2;
  let doorY = y + h - doorH;
  if (door === "west") {
    doorX = x - doorW/2 + 10;
    doorY = y + h/2 - doorH/2;
  } else if (door === "east") {
    doorX = x + w - doorW/2 - 10;
    doorY = y + h/2 - doorH/2;
  } else if (door === "north") {
    doorX = x + w/2 - doorW/2;
    doorY = y - doorH/2;
  }
  ctx.fillStyle = "#1b1c23";
  ctx.fillRect(doorX, doorY, doorW, doorH);
  ctx.strokeRect(doorX, doorY, doorW, doorH);

  if (label) {
    ctx.fillStyle = accent;
    ctx.font = "bold 16px system-ui, sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(label.toUpperCase(), x + w/2, y + h + 28);
  }
}

function addBoundaryWalls(room, options={}) {
  const thickness = options.thickness ?? 16;
  const gap = options.gap ?? 140;
  const open = Object.assign(
    { north: false, south: false, east: false, west: false },
    options.open || {}
  );
  const halfGap = gap / 2;
  const cx = W / 2;
  const cy = H / 2;

  // Top wall
  if (open.north) {
    if (cx - halfGap > 0) room.walls.push({ x: 0, y: 0, w: cx - halfGap, h: thickness });
    if (cx + halfGap < W) room.walls.push({ x: cx + halfGap, y: 0, w: W - (cx + halfGap), h: thickness });
  } else {
    room.walls.push({ x: 0, y: 0, w: W, h: thickness });
  }

  // Bottom wall
  if (open.south) {
    if (cx - halfGap > 0) room.walls.push({ x: 0, y: H - thickness, w: cx - halfGap, h: thickness });
    if (cx + halfGap < W) room.walls.push({ x: cx + halfGap, y: H - thickness, w: W - (cx + halfGap), h: thickness });
  } else {
    room.walls.push({ x: 0, y: H - thickness, w: W, h: thickness });
  }

  // Left wall
  if (open.west) {
    if (cy - halfGap > 0) room.walls.push({ x: 0, y: 0, w: thickness, h: cy - halfGap });
    if (cy + halfGap < H) room.walls.push({ x: 0, y: cy + halfGap, w: thickness, h: H - (cy + halfGap) });
  } else {
    room.walls.push({ x: 0, y: 0, w: thickness, h: H });
  }

  // Right wall
  if (open.east) {
    if (cy - halfGap > 0) room.walls.push({ x: W - thickness, y: 0, w: thickness, h: cy - halfGap });
    if (cy + halfGap < H) room.walls.push({ x: W - thickness, y: cy + halfGap, w: thickness, h: H - (cy + halfGap) });
  } else {
    room.walls.push({ x: W - thickness, y: 0, w: thickness, h: H });
  }
}

function addSecretDoor(room, rect, targetRoom, targetDir, targetEntry, requiresItem) {
  room.secretDoors.push({ rect, targetRoom, targetDir, targetEntry, requiresItem });
}

function createRoomAdder(world) {
  return function addRoom(id, name, options={}, setup) {
    const room = new Room(id, name, options);
    world.rooms[id] = room;
    if (typeof setup === "function") setup(room);
    return room;
  };
}

/* =========================================================
   Assets (loaded from kid-specific directories)
   ========================================================= */
const DEFAULT_KID_ID = "eli";
const ASSET_CONFIG = {
  eli: {
    displayName: "Eli",
    assets: {
      player: "assets/kids/eli/player.png",
      dragon: "assets/common/dragon.png",
      dragonDead: "assets/common/dragon-dead.png",
      key: "assets/common/key.png",
      sword: "assets/common/sword.png",
      trophy: "assets/common/trophy.png"
    }
  },
  isla: {
    displayName: "Isla",
    assets: {
      player: "assets/kids/isla/player.png",
      dragon: "assets/common/dragon.png",
      dragonDead: "assets/common/dragon-dead.png",
      key: "assets/common/key.png",
      sword: "assets/common/sword.png",
      trophy: "assets/common/trophy.png"
    }
  },
  kylie: {
    displayName: "Kylie",
    assets: {
      player: "assets/kids/kylie/player.png",
      dragon: "assets/common/dragon.png",
      dragonDead: "assets/common/dragon-dead.png",
      key: "assets/common/key.png",
      sword: "assets/common/sword.png",
      trophy: "assets/common/trophy.png"
    }
  }
};

const LEVEL_CONFIG = {
  l1: {
    label: "Level 1 – Garden Patrol",
    variants: ["classic", "shuffled"]
  },
  l2: {
    label: "Level 2 – Labyrinth Trek",
    variants: ["labyrinth", "catacombs"]
  },
  l3: {
    label: "Level 3 – Dragon Gauntlet",
    variants: ["highlands", "gauntlet"]
  }
};

const DEFAULT_LEVEL_ID = "l1";
const searchParams = new URLSearchParams(location.search);
const queryKid = searchParams.get("kid");
const queryLevel = searchParams.get("level");
let activeKidId = (queryKid && ASSET_CONFIG[queryKid]) ? queryKid : DEFAULT_KID_ID;
let activeKidName = ASSET_CONFIG[activeKidId]?.displayName || "Default Hero";
let activeLevelId = (queryLevel && LEVEL_CONFIG[queryLevel]) ? queryLevel : DEFAULT_LEVEL_ID;
let activeLevelName = LEVEL_CONFIG[activeLevelId]?.label || LEVEL_CONFIG[DEFAULT_LEVEL_ID].label;
const IMAGES = { player: null, dragon: null, dragonDead: null, key: null, sword: null, trophy: null };
const ITEM_DEFS = {
  sword: { label: "Sword", color: "#dfe6ef", imageKey: "sword" },
  trophy: { label: "Trophy", color: "#f7b500", imageKey: "trophy" },
  bridge: { label: "Bridge", color: "#8bc6ff", imageKey: null },
  "key-yellow": { label: "Yellow Key", color: "#f6d26a", gateColor: "#d1ac3b", imageKey: "key" },
  "key-black": { label: "Black Key", color: "#9aa0a6", gateColor: "#3b3b3b", imageKey: "key" },
  "key-green": { label: "Green Key", color: "#72e39a", gateColor: "#2b9154", imageKey: "key" },
  "key-white": { label: "White Key", color: "#e8eef8", gateColor: "#cfd8e3", imageKey: "key" },
  key: { label: "Yellow Key", color: "#f6d26a", gateColor: "#d1ac3b", imageKey: "key" }
};

function normalizeKeyKind(kind) {
  if (kind === "key") return "key-yellow";
  return kind;
}

function itemDef(kind) {
  return ITEM_DEFS[normalizeKeyKind(kind)] || { label: kind.toUpperCase(), color: "#888", imageKey: null };
}

function itemDisplayName(kind) {
  return itemDef(kind).label;
}

function gateColorForKey(kind) {
  const def = itemDef(kind);
  return def.gateColor || "#2b9154";
}

function loadKidAssets(kidId) {
  const kid = ASSET_CONFIG[kidId] || ASSET_CONFIG[DEFAULT_KID_ID];
  activeKidName = kid.displayName || kidId;
  updateAdventureTitle();
  Object.entries(kid.assets).forEach(([key, url]) => loadAssetImage(key, url));
}

function loadAssetImage(key, url) {
  const img = new Image();
  img.onload = () => { IMAGES[key] = img; };
  img.onerror = () => {
    console.warn(`Failed to load asset ${key} from ${url}. Using fallback.`);
    IMAGES[key] = null;
  };
  img.src = url;
}

function populateKidSelector() {
  const select = document.getElementById("kidSelect");
  if (!select) return;
  select.innerHTML = "";
  Object.entries(ASSET_CONFIG).forEach(([id, cfg]) => {
    const opt = document.createElement("option");
    opt.value = id;
    opt.textContent = cfg.displayName || id;
    select.appendChild(opt);
  });
  select.value = activeKidId;
  select.addEventListener("change", (event) => {
    const nextId = event.target.value;
    if (!ASSET_CONFIG[nextId]) return;
    activeKidId = nextId;
    loadKidAssets(activeKidId);
    syncQueryParams();
    const label = ASSET_CONFIG[activeKidId].displayName || activeKidId;
    showToast(`Now playing as ${label}`);
    WORLD.resetPlayerToStart(false);
  });
}

function populateLevelSelector() {
  const select = document.getElementById("levelSelect");
  if (!select) return;
  select.innerHTML = "";
  Object.entries(LEVEL_CONFIG).forEach(([id, cfg]) => {
    const opt = document.createElement("option");
    opt.value = id;
    opt.textContent = cfg.label;
    select.appendChild(opt);
  });
  select.value = activeLevelId;
  select.addEventListener("change", (event) => {
    const nextId = event.target.value;
    if (!LEVEL_CONFIG[nextId]) return;
    activeLevelId = nextId;
    activeLevelName = LEVEL_CONFIG[activeLevelId]?.label || LEVEL_CONFIG[DEFAULT_LEVEL_ID].label;
    syncQueryParams();
    showToast(`Level set to ${activeLevelName}`);
    WORLD.resetAll();
  });
}

function syncQueryParams() {
  const url = new URL(window.location.href);
  if (activeKidId === DEFAULT_KID_ID) url.searchParams.delete("kid"); else url.searchParams.set("kid", activeKidId);
  if (activeLevelId === DEFAULT_LEVEL_ID) url.searchParams.delete("level"); else url.searchParams.set("level", activeLevelId);
  history.replaceState(null, "", url);
}

function updateAdventureTitle() {
  const titleEl = document.getElementById("gameTitle");
  if (!titleEl) return;
  const suffix = activeKidName.endsWith("s") ? "'" : "'s";
  titleEl.textContent = `${activeKidName}${suffix} Adventure`;
}

loadKidAssets(activeKidId);
populateKidSelector();
populateLevelSelector();
updateAdventureTitle();

/* =========================================================
   World + Rooms (2x2 grid)
   ========================================================= */

class Gate {
  constructor(x,y,w,h, options={}) {
    this.rect = { x, y, w, h };
    this.open = options.open ?? false;
    this.requiredKey = options.requiredKey ?? "key-yellow";
    this.targetRoom = options.targetRoom || null;
    this.targetDir = options.targetDir || "default";
    this.targetEntry = options.targetEntry || null;
    this.closedColor = options.closedColor || gateColorForKey(this.requiredKey);
  }
  tryOpen(player) {
    if (this.open || !player.holding) return;
    const heldKind = normalizeKeyKind(player.holding.kind);
    const required = normalizeKeyKind(this.requiredKey);
    const canOpen = heldKind === "key-white" || heldKind === required;
    if (canOpen && rectsTouchOrOverlap(player, this.rect, 2)) {
      this.open = true;
      this.closedColor = gateColorForKey(this.requiredKey);
      showToast("Gate opened");
    }
  }
  tryEnter(player) {
    if (!this.open || !this.targetRoom) return;
    if (rectsOverlap(player, this.rect)) {
      WORLD.transitionTo(this.targetRoom, this.targetDir, { overrides: this.targetEntry || {}, carryHeld: true });
    }
  }
  blockRect() { return this.open ? null : this.rect; }
  draw() {
    const gateColor = this.closedColor || gateColorForKey(this.requiredKey);
    if (this.open) {
      // open gate "posts"
      const postW = Math.min(14, this.rect.w/3);
      drawRect({x:this.rect.x, y:this.rect.y, w:postW, h:this.rect.h}, gateColor);
      drawRect({x:this.rect.x+this.rect.w-postW, y:this.rect.y, w:postW, h:this.rect.h}, gateColor);
    } else {
      drawRect(this.rect, gateColor);
      outlineRect(this.rect, "#1b1f27");
      // horizontal bar across the door for clarity
      ctx.fillStyle = "#1b1f27";
      ctx.fillRect(this.rect.x, this.rect.y + this.rect.h/2 - 6, this.rect.w, 12);
    }
  }
}

class Item {
  constructor(kind, x,y,w,h) {
    this.kind = kind; // "key-*" | "sword" | "bridge" | "trophy"
    this.x=x; this.y=y; this.w=w; this.h=h;
    this.heldBy = null;
    this.alive = true;
    this.roomId = null;
  }
  rect(){ return this; }
  draw() {
    const r = this.rect();
    const def = itemDef(this.kind);
    const img = def.imageKey ? IMAGES[def.imageKey] : null;
    const label = def.label ? def.label.toUpperCase() : this.kind.toUpperCase();
    drawImageOrFallback(img, r, def.color || "#888", label);
    outlineRect(r, "rgba(0,0,0,.35)");
  }
}

class Dragon {
  constructor(x,y, options={}) {
    this.x=x; this.y=y; this.w=84; this.h=64;
    this.speed = options.speed ?? 180;
    this.aggroRange = options.aggroRange ?? 800;
    this.alive = true;
    this.wanderTimer = 0;
    this.wanderDir = { x: 0, y: 0 };
  }
  rect(){ return this; }
  update(dt, room, player) {
    if (!this.alive) return;
    // target seeking inside room bounds
    const toPlayerX = (player.x + player.w/2) - (this.x + this.w/2);
    const toPlayerY = (player.y + player.h/2) - (this.y + this.h/2);
    const dist = Math.hypot(toPlayerX, toPlayerY);
    let vx = 0, vy = 0;
    if (dist < this.aggroRange) { // aggro
      vx = (toPlayerX / (dist||1)) * this.speed;
      vy = (toPlayerY / (dist||1)) * this.speed;
    } else {
      // idle drift with occasional turns
      this.wanderTimer -= dt;
      if (this.wanderTimer <= 0) {
        const angle = Math.random() * Math.PI * 2;
        this.wanderDir.x = Math.cos(angle);
        this.wanderDir.y = Math.sin(angle);
        this.wanderTimer = 1 + Math.random() * 2;
      }
      vx = this.wanderDir.x * 60;
      vy = this.wanderDir.y * 60;
    }
    this._move(vx*dt, vy*dt, room);
    // attack
    if (rectsOverlap(this, player) && !player.invulnTimer) {
      player.onHit();
    }
  }
  _move(dx, dy, room) {
    const solids = room.solidRects();
    this.x += dx;
    for (const s of solids) if (rectsOverlap(this, s)) {
      if (dx > 0) this.x = s.x - this.w; else if (dx < 0) this.x = s.x + s.w;
    }
    this.y += dy;
    for (const s of solids) if (rectsOverlap(this, s)) {
      if (dy > 0) this.y = s.y - this.h; else if (dy < 0) this.y = s.y + s.h;
    }
    this.x = clamp(this.x, 0, W - this.w);
    this.y = clamp(this.y, 0, H - this.h);
  }
  draw() {
    const r = this.rect();
    if (this.alive) {
      drawImageOrFallback(IMAGES.dragon, r, "#d54b4b", "DRAGON");
    } else {
      drawImageOrFallback(IMAGES.dragonDead, r, "#5d5d5d", "DEFEATED");
    }
    outlineRect(r, "rgba(0,0,0,.35)");
  }
}

class Bat {
  constructor(x, y, roomId) {
    this.x = x; this.y = y; this.w = 40; this.h = 26;
    this.speed = 160;
    this.roomId = roomId;
    this.carrying = null;
    this.wanderTimer = 0;
    this.wanderDir = { x: 0, y: 0 };
    this.travelTimer = 3 + Math.random() * 4;
    this.dropTimer = 2 + Math.random() * 3;
  }
  rect(){ return this; }
  update(dt, world) {
    const room = world.rooms[this.roomId];
    if (!room) return;

    this.travelTimer -= dt;
    if (this.travelTimer <= 0) {
      this.travelTimer = 3 + Math.random() * 5;
      const exits = Object.entries(room.neighbors).filter(([dir, id]) => id);
      if (exits.length) {
        const [dir, nextId] = exits[Math.floor(Math.random() * exits.length)];
        this._moveToRoom(nextId, dir);
        return;
      }
    }

    this.wanderTimer -= dt;
    if (this.wanderTimer <= 0) {
      const angle = Math.random() * Math.PI * 2;
      this.wanderDir.x = Math.cos(angle);
      this.wanderDir.y = Math.sin(angle);
      this.wanderTimer = 0.7 + Math.random() * 1.2;
    }
    this.x += this.wanderDir.x * this.speed * dt;
    this.y += this.wanderDir.y * this.speed * dt;

    if (this.x + this.w > W) {
      const target = room.neighbors.east;
      if (target) { this._moveToRoom(target, "west"); return; }
      this.x = W - this.w;
    }
    if (this.x < 0) {
      const target = room.neighbors.west;
      if (target) { this._moveToRoom(target, "east"); return; }
      this.x = 0;
    }
    if (this.y + this.h > H) {
      const target = room.neighbors.south;
      if (target) { this._moveToRoom(target, "north"); return; }
      this.y = H - this.h;
    }
    if (this.y < 0) {
      const target = room.neighbors.north;
      if (target) { this._moveToRoom(target, "south"); return; }
      this.y = 0;
    }

    this._stealFromRoom(room, world);
    this._maybeDrop(world, dt);
  }
  _moveToRoom(nextId, incomingDir) {
    this.roomId = nextId;
    const margin = 18;
    if (incomingDir === "west") {
      this.x = margin;
      this.y = clamp(this.y, margin, H - this.h - margin);
    } else if (incomingDir === "east") {
      this.x = W - this.w - margin;
      this.y = clamp(this.y, margin, H - this.h - margin);
    } else if (incomingDir === "north") {
      this.y = margin;
      this.x = clamp(this.x, margin, W - this.w - margin);
    } else if (incomingDir === "south") {
      this.y = H - this.h - margin;
      this.x = clamp(this.x, margin, W - this.w - margin);
    } else {
      this.x = clamp(this.x, margin, W - this.w - margin);
      this.y = clamp(this.y, margin, H - this.h - margin);
    }
  }
  _stealFromRoom(room, world) {
    if (this.carrying) return;
    for (const it of room.items) {
      if (it.alive && !it.heldBy && rectsOverlap(this, it)) {
        world.removeItemFromRoom(it);
        this.carrying = it;
        return;
      }
    }
    if (world.player.holding && this.roomId === world.currentRoomId && rectsOverlap(this, world.player)) {
      this.carrying = world.player.holding;
      this.carrying.heldBy = null;
      world.player.holding = null;
      showToast("Bat stole your item!");
    }
  }
  _maybeDrop(world, dt) {
    if (!this.carrying) return;
    this.dropTimer -= dt;
    if (this.dropTimer > 0) return;
    this.dropTimer = 2 + Math.random() * 4;
    const it = this.carrying;
    this.carrying = null;
    it.x = clamp(this.x + this.w + 6, 8, W - it.w - 8);
    it.y = clamp(this.y + (this.h - it.h)/2, 8, H - it.h - 8);
    world.addItemToRoom(it, this.roomId);
  }
  draw() {
    const r = this.rect();
    drawRect(r, "#6c7a89");
    outlineRect(r, "#2b3038");
    ctx.fillStyle = "#1b1f27";
    ctx.font = "bold 10px system-ui, sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("BAT", r.x + r.w/2, r.y + r.h/2);
    if (this.carrying && this.roomId === WORLD.currentRoomId) {
      const it = this.carrying;
      const cx = r.x + r.w/2;
      const cy = r.y - it.h - 4;
      it.x = clamp(cx - it.w/2, 8, W - it.w - 8);
      it.y = clamp(cy, 8, H - it.h - 8);
      it.draw();
    }
  }
}

function findSecretDoor(room, player) {
  if (!room.secretDoors || !room.secretDoors.length) return null;
  for (const door of room.secretDoors) {
    if (!rectsOverlap(player, door.rect)) continue;
    if (!door.requiresItem) return door;
    if (!player.holding) continue;
    const heldKind = normalizeKeyKind(player.holding.kind);
    const reqKind = normalizeKeyKind(door.requiresItem);
    if (heldKind === reqKind || heldKind === "key-white") return door;
  }
  return null;
}

class Player {
  constructor() {
    this.x=40; this.y=H/2-20; this.w=48; this.h=48;
    this.speed = 210;
    this.holding = null; // Item
    this.invulnTimer = 0;
  }
  rect(){ return this; }
  update(dt, room) {
    // movement
    let dx=0, dy=0;
    if (heldDirection("left")) dx -= 1;
    if (heldDirection("right")) dx += 1;
    if (heldDirection("up")) dy -= 1;
    if (heldDirection("down")) dy += 1;
    if (dx || dy) {
      const mag = Math.hypot(dx, dy) || 1;
      dx = (dx/mag) * this.speed * dt;
      dy = (dy/mag) * this.speed * dt;
    }
    if (this._move(dx, dy, room)) {
      return;
    }

    const secretDoor = findSecretDoor(room, this);
    if (secretDoor) {
      WORLD.transitionTo(secretDoor.targetRoom, secretDoor.targetDir || "default", { overrides: secretDoor.targetEntry || {}, carryHeld: true });
      return;
    }

    // gate interaction
    if (room.gate) {
      room.gate.tryOpen(this);
      room.gate.tryEnter(this);
    }

    // pick / drop
    if (wasPressed("e") || touchActionPressed("interact")) {
      if (this.holding) {
        // use on gate if touching it and it's closed
        // otherwise do nothing here; dropping is Q
      } else {
        // try pick up nearest item overlapping
        for (const it of room.items) {
          if (it.alive && !it.heldBy && rectsOverlap(this, it)) {
            WORLD.removeItemFromRoom(it);
            this.holding = it; it.heldBy = this;
            showToast(`Picked up ${itemDisplayName(it.kind)}`);
            break;
          }
        }
      }
    }
    if (wasPressed("q") || touchActionPressed("drop")) {
      if (this.holding) {
        const it = this.holding;
        it.heldBy = null; this.holding = null;
        it.x = clamp(this.x + this.w + 6, 8, W - it.w - 8);
        it.y = clamp(this.y + (this.h - it.h)/2, 8, H - it.h - 8);
        resolveItemGateOverlap(it, room, this);
        WORLD.addItemToRoom(it, WORLD.currentRoomId);
        showToast(`Dropped ${itemDisplayName(it.kind)}`);
      }
    }

    // carry follow
    if (this.holding) {
      const it = this.holding;
      it.x = this.x + this.w + 4;
      it.y = this.y + (this.h - it.h)/2;
    }

    if (this.invulnTimer > 0) this.invulnTimer -= dt;
  }
  _move(dx, dy, room) {
    const useBridge = this.holding && this.holding.kind === "bridge";
    const solids = room.solidRects({ ignoreWalls: useBridge });
    this.x += dx;
    for (const s of solids) if (rectsOverlap(this, s)) {
      if (dx > 0) this.x = s.x - this.w; else if (dx < 0) this.x = s.x + s.w;
    }
    this.y += dy;
    for (const s of solids) if (rectsOverlap(this, s)) {
      if (dy > 0) this.y = s.y - this.h; else if (dy < 0) this.y = s.y + s.h;
    }

    // room edge travel
    if (this.x + this.w > W) {
      const target = room.neighbors.east;
      if (target) {
        const newY = clamp(this.y, 32, H - this.h - 32);
        WORLD.transitionTo(target, "west", { overrides: { y: newY }, carryHeld: true });
        return true;
      } else {
        this.x = W - this.w;
      }
    }
    if (this.x < 0) {
      const target = room.neighbors.west;
      if (target) {
        const newY = clamp(this.y, 32, H - this.h - 32);
        WORLD.transitionTo(target, "east", { overrides: { y: newY }, carryHeld: true });
        return true;
      } else {
        this.x = 0;
      }
    }
    if (this.y + this.h > H) {
      const target = room.neighbors.south;
      if (target) {
        const newX = clamp(this.x, 32, W - this.w - 32);
        WORLD.transitionTo(target, "north", { overrides: { x: newX }, carryHeld: true });
        return true;
      } else {
        this.y = H - this.h;
      }
    }
    if (this.y < 0) {
      const target = room.neighbors.north;
      if (target) {
        const newX = clamp(this.x, 32, W - this.w - 32);
        WORLD.transitionTo(target, "south", { overrides: { x: newX }, carryHeld: true });
        return true;
      } else {
        this.y = 0;
      }
    }
    return false;
  }
  onHit() {
    this.invulnTimer = 1.2;
    showToast("You were eaten! Back to start...");
    WORLD.resetPlayerToStart(true);
  }
  draw() {
    const r = this.rect();
    drawImageOrFallback(IMAGES.player, r, "#ffd54a", "PLAYER");
    if (this.invulnTimer > 0) {
      ctx.globalAlpha = 0.35 + 0.25*Math.sin(perfNow()*0.02);
      outlineRect(r, "#ffe082");
      ctx.globalAlpha = 1;
    } else {
      outlineRect(r, "rgba(0,0,0,.35)");
    }
  }
}

class Room {
  constructor(id, name, options={}) {
    this.id = id;
    this.name = name;
    this.neighbors = options.neighbors || {};
    this.entryPoints = options.entryPoints || {};
    this.bgColor = options.bgColor || "#0b0f15";
    this.walls = [];
    this.invisibleWalls = [];
    this.items = [];
    this.enemies = [];
    this.gate = null;
    this.pedestal = null;
    this.secretDoors = [];
  }
  solidRects(options={}) {
    const ignoreWalls = options.ignoreWalls || false;
    const solids = [];
    if (!ignoreWalls) {
      solids.push(...this.walls);
      if (this.invisibleWalls.length) solids.push(...this.invisibleWalls);
    }
    if (this.gate && !this.gate.open) solids.push(this.gate.rect);
    return solids;
  }
  entryPoint(dir="default") {
    return this.entryPoints[dir] || this.entryPoints.default || null;
  }
  drawBackdrop() {
    // mild vignette grid for flavor
    ctx.fillStyle = this.bgColor;
    ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = "#0f141b";
    ctx.lineWidth = 1;
    const grid = 48;
    ctx.beginPath();
    for (let x=0; x<=W; x+=grid){ ctx.moveTo(x+.5,0); ctx.lineTo(x+.5,H); }
    for (let y=0; y<=H; y+=grid){ ctx.moveTo(0,y+.5); ctx.lineTo(W,y+.5); }
    ctx.stroke();
  }
  draw() {
    this.drawBackdrop();
    // walls first
    for (const w of this.walls) { drawWallRect(w, "#2d3542", "#11161d"); }
    // pedestal
    if (this.pedestal) {
      drawRect(this.pedestal, "#343b46");
      outlineRect(this.pedestal, "#4b5564");
      ctx.fillStyle = "#aab4c0";
      ctx.font = "bold 12px system-ui,sans-serif";
      ctx.textAlign="center"; ctx.textBaseline="top";
      ctx.fillText("PEDESTAL", this.pedestal.x + this.pedestal.w/2, this.pedestal.y + this.pedestal.h + 4);
    }
    // castle overlay for clarity
    if (this.castle) {
      drawCastleSilhouette(this.castle);
    }
    // gate on top
    if (this.gate) this.gate.draw();
    // items (not held)
    for (const it of this.items) if (it.alive && !it.heldBy) it.draw();
    // enemies
    for (const e of this.enemies) if (e.alive) e.draw();
  }
}

const START_ROOM_ID = "meadow";
const WORLD = {
  rooms: {},
  currentRoomId: START_ROOM_ID,
  currentLayoutId: null,
  currentLayoutName: "",
  player: new Player(),
  bat: null,
  buildRandomLayout() {
    const level = LEVEL_CONFIG[activeLevelId] || LEVEL_CONFIG[DEFAULT_LEVEL_ID];
    const variantIds = (level?.variants || []).filter(id => LAYOUT_VARIANTS[id]);
    const fallbackIds = Object.keys(LAYOUT_VARIANTS);
    const idsToUse = variantIds.length ? variantIds : fallbackIds;
    let pool = idsToUse.filter(id => id !== this.currentLayoutId);
    if (!pool.length) pool = idsToUse;
    const choiceId = pool[Math.floor(Math.random() * pool.length)];
    const variant = LAYOUT_VARIANTS[choiceId];
    this.currentLayoutId = choiceId;
    this.currentLayoutName = `${level.label} · ${variant.label}`;
    variant.builder(this);
  },
  addItemToRoom(item, roomId) {
    const room = this.rooms[roomId];
    if (!room) return;
    item.roomId = roomId;
    room.items.push(item);
  },
  removeItemFromRoom(item) {
    if (!item.roomId) return;
    const room = this.rooms[item.roomId];
    if (room) {
      const idx = room.items.indexOf(item);
      if (idx >= 0) room.items.splice(idx, 1);
    }
    item.roomId = null;
  },
  current() {
    return this.rooms[this.currentRoomId];
  },
  transitionTo(roomId, incomingDir="default", opts={}) {
    const room = this.rooms[roomId];
    if (!room) return;
    this.currentRoomId = roomId;
    const defaults = this.defaultEntry(incomingDir);
    const target = room.entryPoint(incomingDir) || {};
    const overrides = opts.overrides || {};
    const spawn = {
      x: overrides.x ?? target.x ?? defaults.x,
      y: overrides.y ?? target.y ?? defaults.y
    };
    this.player.x = clamp(spawn.x ?? W/2 - this.player.w/2, 16, W - this.player.w - 16);
    this.player.y = clamp(spawn.y ?? H/2 - this.player.h/2, 16, H - this.player.h - 16);
    if (opts.carryHeld && this.player.holding) {
      this.player.holding.x = this.player.x + this.player.w + 4;
      this.player.holding.y = this.player.y + (this.player.h - this.player.holding.h)/2;
    }
    if (!opts.silent) {
      showToast(`Entered: ${room.name}`, 900);
    }
  },
  defaultEntry(dir="default") {
    const margin = 28;
    const p = this.player || { x: W/2 - 24, y: H/2 - 24, w: 48, h: 48 };
    switch (dir) {
      case "west":
        return { x: margin, y: clamp(p.y, margin, H - p.h - margin) };
      case "east":
        return { x: W - p.w - margin, y: clamp(p.y, margin, H - p.h - margin) };
      case "north":
        return { x: clamp(p.x, margin, W - p.w - margin), y: margin };
      case "south":
        return { x: clamp(p.x, margin, W - p.w - margin), y: H - p.h - margin };
      default:
        return { x: 80, y: H/2 - p.h/2 };
    }
  },
  update(dt) {
    const room = this.current();
    for (const d of room.enemies) d.update(dt, room, this.player);
    if (this.bat) this.bat.update(dt, this);
    this.player.update(dt, room);

    if (this.player.holding && this.player.holding.kind === "sword") {
      for (const e of room.enemies) {
        if (e.alive && rectsOverlap(this.player.holding, e)) {
          e.alive = false;
          showToast("Dragon defeated!");
        }
      }
    }

    if (room.pedestal) {
      const ped = room.pedestal;
      for (const itm of room.items) {
        if (itm.kind === "trophy" && itm.alive && !itm.heldBy && rectsOverlap(itm, ped)) {
          state.winTimer = Math.max(state.winTimer, 0.001);
        }
      }
    }
  },
  draw() {
    const room = this.current();
    room.draw();
    if (this.bat && this.bat.roomId === this.currentRoomId) {
      this.bat.draw();
    }
    if (this.player.holding) this.player.holding.draw();
    this.player.draw();
  },
  resetPlayerToStart(dropHeld) {
    const held = this.player.holding;
    this.transitionTo(START_ROOM_ID, "default", { silent: dropHeld });
    if (held && dropHeld) {
      held.heldBy = null;
      this.player.holding = null;
      this.addItemToRoom(held, this.currentRoomId);
      held.x = this.player.x + this.player.w + 6;
      held.y = this.player.y + (this.player.h - held.h)/2;
    } else if (held) {
      held.x = this.player.x + this.player.w + 4;
      held.y = this.player.y + (this.player.h - held.h)/2;
    }
  },
  resetAll() {
    this.player = new Player();
    this.bat = null;
    this.buildRandomLayout();
    this.transitionTo(START_ROOM_ID, "default", { silent: true });
    state.winTimer = 0;
    if (this.currentLayoutName) {
      showToast(`Layout: ${this.currentLayoutName}`, 2000);
    }
  }
};

const LAYOUT_VARIANTS = {
  classic: { label: "Classic Grounds", builder: buildClassicLayout },
  shuffled: { label: "Shuffled Paths", builder: buildShuffledLayout },
  labyrinth: { label: "Labyrinth Run", builder: buildLabyrinthLayout },
  catacombs: { label: "Catacombs", builder: buildCatacombsLayout },
  highlands: { label: "Highlands", builder: buildHighlandsLayout },
  gauntlet: { label: "Dragon Gauntlet", builder: buildGauntletLayout }
};

function buildClassicLayout(world) {
  world.rooms = {};
  const addRoom = createRoomAdder(world);

  addRoom("meadow", "Yellow Castle Grounds", {
    neighbors: { north: "ridge", east: "yellowCourtyard", south: "riverbank" },
    entryPoints: { default: { x: 72, y: H/2 - 24 } },
    bgColor: "#162316"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, west: true, east: true, south: true } });
    room.walls.push(
      { x: 200, y: 140, w: 20, h: 320 },
      { x: 360, y: 140, w: 20, h: 320 }
    );
  });

  addRoom("ridge", "Hill Ridge", {
    neighbors: { south: "meadow", east: "ruins" },
    bgColor: "#1a2418"
  }, (room) => {
    addBoundaryWalls(room, { open: { south: true, east: true } });
    room.walls.push(
      { x: 160, y: 80, w: 24, h: 440 },
      { x: 520, y: 100, w: 24, h: 400 }
    );
  });

  addRoom("ruins", "Old Ruins", {
    neighbors: { west: "ridge", east: "oldShrine" },
    bgColor: "#262c2a"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
    room.walls.push(
      { x: 220, y: 120, w: 40, h: 360 },
      { x: 480, y: 160, w: 40, h: 300 }
    );
  });

  addRoom("oldShrine", "Hidden Shrine", {
    neighbors: { west: "ruins" },
    bgColor: "#1b1e24"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.walls.push(
      { x: 300, y: 120, w: 20, h: 360 },
      { x: 520, y: 80, w: 20, h: 440 }
    );
  });

  addRoom("yellowCourtyard", "Yellow Castle Gate", {
    neighbors: { west: "meadow" },
    bgColor: "#1e1d26"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.entryPoints = {
      west: { x: 80, y: H/2 - 40 },
      east: { x: W - 180, y: H/2 - 40 }
    };
    room.castle = { color: "#f4d26a", accent: "#fff2a1", door: "west", label: "Yellow Castle", x: 280, y: 120, w: 360, h: 280 };
    room.walls = [];
    room.gate = new Gate(280 + 360/2 - 45, 120 + 280 - 130, 90, 120, {
      targetRoom: "yellowHall",
      targetDir: "west",
      targetEntry: { x: 140, y: H/2 - 30 },
      requiredKey: "key-yellow",
      open: false
    });
  });

  addRoom("yellowHall", "Yellow Castle Interior", {
    neighbors: { west: "yellowCourtyard" },
    entryPoints: { default: { x: 120, y: H/2 - 30 } },
    bgColor: "#2a2415"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#9d8435", accent: "#ffe4a6", door: "east", label: "Throne Room", x: 180, y: 120, w: 520, h: 280 };
    room.walls.push(
      { x: 300, y: 160, w: 20, h: 280 },
      { x: 500, y: 120, w: 20, h: 360 }
    );
  });

  addRoom("riverbank", "Riverbank", {
    neighbors: { north: "meadow", east: "woods", south: "swamp" },
    bgColor: "#0b1e2b"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true, south: true } });
    room.walls.push(
      { x: 0, y: H/2 - 60, w: 320, h: 60 },
      { x: 580, y: H/2 - 60, w: 380, h: 60 },
      { x: 220, y: 0, w: 20, h: H/2 - 120 },
      { x: 520, y: H/2, w: 20, h: H/2 }
    );
  });

  addRoom("woods", "Dark Woods", {
    neighbors: { west: "riverbank", east: "blackEntrance" },
    bgColor: "#192011"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
    room.walls.push(
      { x: 160, y: 80, w: 40, h: 440 },
      { x: 360, y: 120, w: 40, h: 360 },
      { x: 560, y: 80, w: 40, h: 440 }
    );
  });

  addRoom("blackEntrance", "Black Castle Gate", {
    neighbors: { west: "woods", east: "blackHall" },
    bgColor: "#111"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
    room.castle = { color: "#444", accent: "#bbb", door: "west", label: "Black Castle", x: 260, y: 140, w: 400, h: 260 };
    room.walls.push(
      { x: 260, y: 160, w: 20, h: 260 },
      { x: 520, y: 160, w: 20, h: 260 }
    );
    room.gate = new Gate(W/2 - 45, H/2 - 60, 90, 120, {
      targetRoom: "blackHall",
      targetDir: "west",
      targetEntry: { x: 140, y: H/2 - 30 },
      requiredKey: "key-black",
      open: false
    });
  });

  addRoom("blackHall", "Black Castle Interior", {
    neighbors: { west: "blackEntrance" },
    bgColor: "#1c1c1c"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#2b2b2b", accent: "#e1e1e1", door: "east", label: "Dungeon", x: 220, y: 100, w: 520, h: 300 };
    room.walls.push(
      { x: 380, y: 120, w: 20, h: 360 }
    );
  });

  addRoom("swamp", "Swamp", {
    neighbors: { north: "riverbank", west: "marshEdge", east: "greenMaze", south: "dragonLair" },
    bgColor: "#132018"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true, south: true } });
    room.walls.push(
      { x: 160, y: 160, w: 120, h: 120 },
      { x: 420, y: 100, w: 40, h: 180 },
      { x: 620, y: 320, w: 80, h: 160 }
    );
  });

  addRoom("marshEdge", "Marsh Edge", {
    neighbors: { east: "swamp" },
    bgColor: "#101a14"
  }, (room) => {
    addBoundaryWalls(room, { open: { east: true } });
    room.walls.push(
      { x: 220, y: 140, w: 40, h: 320 },
      { x: 480, y: 100, w: 40, h: 360 }
    );
  });

  addRoom("greenMaze", "Green Maze", {
    neighbors: { west: "swamp", east: "greenEntrance" },
    bgColor: "#0f2a1d"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
    room.walls.push(
      { x: 200, y: 80, w: 20, h: 400 },
      { x: 200, y: 80, w: 240, h: 20 },
      { x: 440, y: 80, w: 20, h: 360 },
      { x: 440, y: 420, w: 200, h: 20 },
      { x: 640, y: 140, w: 20, h: 320 }
    );
  });

  addRoom("greenEntrance", "Green Castle Gate", {
    neighbors: { west: "greenMaze", east: "greenHall" },
    bgColor: "#1b2a15"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
    room.gate = new Gate(W/2 - 45, H/2 - 60, 90, 120, {
      targetRoom: "greenHall",
      targetDir: "west",
      targetEntry: { x: 140, y: H/2 - 26 },
      requiredKey: "key-green",
      open: false
    });
    room.castle = { color: "#4c6f3f", accent: "#aee09a", door: "west", label: "Green Castle", x: 260, y: 140, w: 420, h: 260 };
    room.walls.push(
      { x: 260, y: 140, w: 20, h: 320 },
      { x: 520, y: 140, w: 20, h: 320 }
    );
  });

  addRoom("greenHall", "Green Castle Interior", {
    neighbors: { west: "greenEntrance" },
    bgColor: "#2d3f23",
    entryPoints: { west: { x: 140, y: H/2 - 26 }, default: { x: 140, y: H/2 - 26 } }
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#36502f", accent: "#d8ffc4", door: "east", label: "Treasure Room", x: 220, y: 120, w: 520, h: 280 };
    room.walls.push(
      { x: 320, y: 120, w: 20, h: 360 }
    );
  });

  addRoom("hiddenGrotto", "Hidden Grotto", {
    neighbors: {},
    bgColor: "#0f141a"
  }, (room) => {
    addBoundaryWalls(room, {});
    room.walls.push(
      { x: 240, y: 120, w: 20, h: 360 },
      { x: 520, y: 120, w: 20, h: 360 }
    );
  });

  addRoom("dragonLair", "Dragon Lair", {
    neighbors: { north: "swamp" },
    bgColor: "#250c0c"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true } });
    room.walls.push(
      { x: 220, y: 100, w: 520, h: 40 },
      { x: 220, y: 100, w: 40, h: 360 },
      { x: 220, y: 420, w: 520, h: 40 },
      { x: 700, y: 140, w: 40, h: 280 }
    );
  });

  addSecretDoor(world.rooms.greenMaze, { x: W - 40, y: 80, w: 32, h: 120 }, "hiddenGrotto", "west", { x: 140, y: H/2 - 20 });

  world.addItemToRoom(new Item("sword", 220, H/2 - 16, 64, 24), "meadow");
  world.addItemToRoom(new Item("bridge", 120, H/2 + 100, 72, 20), "riverbank");
  world.addItemToRoom(new Item("key-yellow", 200, 120, 40, 24), "woods");
  world.addItemToRoom(new Item("key-black", 320, H/2 + 20, 40, 24), "yellowHall");
  world.addItemToRoom(new Item("key-green", 300, H/2 - 20, 40, 24), "blackHall");
  world.addItemToRoom(new Item("key-white", 360, H/2 - 10, 40, 24), "hiddenGrotto");
  world.addItemToRoom(new Item("trophy", W - 260, H/2 - 24, 44, 36), "greenHall");

  world.bat = new Bat(240, 160, "woods");
  const dragonFast = new Dragon(W - 260, H/2 - 32, { speed: 220, aggroRange: 900 });
  const dragonSlow = new Dragon(260, 200, { speed: 140, aggroRange: 700 });
  world.rooms.dragonLair.enemies.push(dragonFast);
  world.rooms.swamp.enemies.push(dragonSlow);

  world.currentRoomId = START_ROOM_ID;
}

function buildShuffledLayout(world) {
  world.rooms = {};
  const addRoom = createRoomAdder(world);

  addRoom("meadow", "Hidden Meadow", {
    neighbors: { north: "woods", east: "riverbank", south: "yellowCourtyard" },
    entryPoints: { default: { x: 72, y: H/2 - 24 } },
    bgColor: "#1a2416"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true, south: true } });
    room.walls.push(
      { x: 180, y: 160, w: 20, h: 280 },
      { x: 420, y: 120, w: 20, h: 360 },
      { x: 640, y: 160, w: 20, h: 280 }
    );
  });

  addRoom("yellowCourtyard", "Castle Fork", {
    neighbors: { north: "meadow", south: "swamp" },
    bgColor: "#201c2a"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, south: true } });
    room.castle = { color: "#e7d57f", accent: "#fff7b3", door: "east", label: "Yellow Castle", x: 260, y: 120, w: 380, h: 280 };
    room.walls = [];
    room.gate = new Gate(260 + 380/2 - 45, 120 + 280 - 130, 90, 120, {
      targetRoom: "yellowHall",
      targetDir: "west",
      targetEntry: { x: 110, y: H/2 - 36 },
      requiredKey: "key-yellow",
      open: false
    });
  });

  addRoom("yellowHall", "Golden Keep", {
    neighbors: { west: "yellowCourtyard" },
    entryPoints: { default: { x: 110, y: H/2 - 36 } },
    bgColor: "#3a2c15"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#9f7430", accent: "#ffe6a1", door: "east", label: "Keep", x: 200, y: 140, w: 520, h: 260 };
    room.walls.push(
      { x: 280, y: 160, w: 20, h: 280 },
      { x: 520, y: 140, w: 20, h: 320 }
    );
  });

  addRoom("woods", "Twisted Woods", {
    neighbors: { north: "overlook", south: "meadow", east: "blackEntrance" },
    bgColor: "#111c11"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, south: true, east: true } });
    room.walls.push(
      { x: 220, y: 80, w: 40, h: 440 },
      { x: 480, y: 40, w: 40, h: 520 }
    );
  });

  addRoom("overlook", "Cliff Overlook", {
    neighbors: { south: "woods" },
    bgColor: "#20252f"
  }, (room) => {
    addBoundaryWalls(room, { open: { south: true } });
    room.walls.push(
      { x: 260, y: 120, w: 40, h: 360 },
      { x: 520, y: 120, w: 40, h: 360 }
    );
  });

  addRoom("blackEntrance", "Black Gate", {
    neighbors: { west: "woods", south: "riverbank", east: "blackHall" },
    bgColor: "#0f0f0f"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, south: true, east: true } });
    room.castle = { color: "#3a3a3a", accent: "#cfcfcf", door: "east", label: "Black Castle", x: 320, y: 140, w: 360, h: 260 };
    room.walls.push(
      { x: 320, y: 180, w: 20, h: 220 },
      { x: 600, y: 140, w: 20, h: 320 }
    );
    room.gate = new Gate(W/2 - 45, H/2 - 60, 90, 120, {
      targetRoom: "blackHall",
      targetDir: "west",
      targetEntry: { x: 140, y: H/2 - 30 },
      requiredKey: "key-black",
      open: false
    });
  });

  addRoom("blackHall", "Shadow Hall", {
    neighbors: { west: "blackEntrance" },
    bgColor: "#1a1a1a"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#1f1f1f", accent: "#eeeeee", door: "east", label: "Dungeon", x: 240, y: 120, w: 520, h: 300 };
    room.walls.push(
      { x: 420, y: 100, w: 20, h: 360 }
    );
  });

  addRoom("riverbank", "River Switchbacks", {
    neighbors: { west: "meadow", north: "blackEntrance", south: "swamp", east: "greenMaze" },
    bgColor: "#0d1f30"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, north: true, south: true, east: true } });
    room.walls.push(
      { x: 200, y: 80, w: 20, h: 220 },
      { x: 480, y: 300, w: 20, h: 220 },
      { x: 340, y: 240, w: 200, h: 20 }
    );
  });

  addRoom("swamp", "Bog Crossing", {
    neighbors: { north: "yellowCourtyard", west: "riverbank", east: "greenEntrance", south: "dragonLair" },
    bgColor: "#1b281b"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, west: true, east: true, south: true } });
    room.walls.push(
      { x: 220, y: 120, w: 80, h: 200 },
      { x: 520, y: 280, w: 60, h: 200 }
    );
  });

  addRoom("greenMaze", "Tangled Maze", {
    neighbors: { west: "riverbank", south: "greenEntrance" },
    bgColor: "#123222"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, south: true } });
    room.walls.push(
      { x: 220, y: 80, w: 20, h: 420 },
      { x: 380, y: 80, w: 20, h: 420 },
      { x: 540, y: 80, w: 20, h: 420 }
    );
  });

  addRoom("greenEntrance", "Jade Gate", {
    neighbors: { west: "swamp", east: "greenHall", north: "greenMaze" },
    bgColor: "#1f321e"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true, north: true } });
    room.castle = { color: "#3f6633", accent: "#b9fb9c", door: "west", label: "Green Castle", x: 280, y: 160, w: 400, h: 240 };
    room.walls.push(
      { x: 280, y: 120, w: 20, h: 360 },
      { x: 560, y: 180, w: 20, h: 260 }
    );
    room.gate = new Gate(W/2 - 45, H/2 - 60, 90, 120, {
      targetRoom: "greenHall",
      targetDir: "west",
      targetEntry: { x: 140, y: H/2 - 30 },
      requiredKey: "key-green",
      open: false
    });
  });

  addRoom("greenHall", "Emerald Hall", {
    neighbors: { west: "greenEntrance" },
    bgColor: "#294827"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#345b2c", accent: "#d5ffbd", door: "east", label: "Vault", x: 260, y: 140, w: 520, h: 260 };
    room.walls.push(
      { x: 360, y: 120, w: 20, h: 360 }
    );
  });

  addRoom("dragonLair", "Cavern Maw", {
    neighbors: { north: "swamp", south: "deepMarsh" },
    bgColor: "#2a0f12"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, south: true } });
    room.walls.push(
      { x: 260, y: 100, w: 40, h: 360 },
      { x: 260, y: 100, w: 380, h: 40 },
      { x: 260, y: 420, w: 380, h: 40 }
    );
  });

  addRoom("deepMarsh", "Deep Marsh", {
    neighbors: { north: "dragonLair" },
    bgColor: "#1a1012"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true } });
    room.walls.push(
      { x: 220, y: 140, w: 40, h: 320 },
      { x: 520, y: 120, w: 40, h: 360 }
    );
  });

  addRoom("hiddenVault", "Hidden Vault", {
    neighbors: {},
    bgColor: "#13161d"
  }, (room) => {
    addBoundaryWalls(room, {});
    room.walls.push(
      { x: 240, y: 120, w: 20, h: 360 },
      { x: 520, y: 120, w: 20, h: 360 }
    );
  });

  addSecretDoor(world.rooms.blackHall, { x: W - 36, y: H/2 - 60, w: 28, h: 120 }, "hiddenVault", "west", { x: 140, y: H/2 - 20 });

  world.addItemToRoom(new Item("sword", 140, 120, 56, 20), "meadow");
  world.addItemToRoom(new Item("bridge", 260, H/2 + 120, 72, 20), "riverbank");
  world.addItemToRoom(new Item("key-yellow", 220, 160, 40, 24), "meadow");
  world.addItemToRoom(new Item("key-black", 320, H/2 + 20, 40, 24), "yellowHall");
  world.addItemToRoom(new Item("key-green", 300, H/2 - 10, 40, 24), "blackHall");
  world.addItemToRoom(new Item("key-white", 360, H/2 - 10, 40, 24), "hiddenVault");
  world.addItemToRoom(new Item("trophy", W - 260, H/2 - 24, 44, 36), "greenHall");

  world.bat = new Bat(200, 140, "riverbank");
  const dragonFast = new Dragon(80, H/2 - 32, { speed: 220, aggroRange: 900 });
  const dragonSlow = new Dragon(260, 200, { speed: 140, aggroRange: 700 });
  world.rooms.dragonLair.enemies.push(dragonFast);
  world.rooms.swamp.enemies.push(dragonSlow);

  world.currentRoomId = START_ROOM_ID;
}

function buildLabyrinthLayout(world) {
  world.rooms = {};
  const addRoom = createRoomAdder(world);

  addRoom("meadow", "Sunlit Field", {
    neighbors: { east: "riverbank", south: "mazeEntry" },
    entryPoints: { default: { x: 90, y: H/2 - 30 } },
    bgColor: "#1f301b"
  }, (room) => {
    addBoundaryWalls(room, { open: { east: true, south: true } });
    room.walls.push(
      { x: 260, y: 160, w: 20, h: 260 },
      { x: 520, y: 120, w: 20, h: 320 }
    );
  });

  addRoom("riverbank", "River Crossing", {
    neighbors: { west: "meadow", east: "yellowCourtyard", south: "swamp" },
    bgColor: "#0d2434"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true, south: true } });
    room.walls.push(
      { x: 220, y: 80, w: 20, h: 420 },
      { x: 480, y: 80, w: 20, h: 420 }
    );
  });

  addRoom("yellowCourtyard", "Citadel Approach", {
    neighbors: { west: "riverbank", east: "yellowHall" },
    bgColor: "#251f16"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
    room.castle = { color: "#f1d272", accent: "#fff2ad", door: "west", label: "Yellow Castle", x: 280, y: 100, w: 360, h: 300 };
    room.walls.push(
      { x: 300, y: 120, w: 20, h: 340 },
      { x: 520, y: 120, w: 20, h: 340 }
    );
    room.gate = new Gate(280 + 360/2 - 45, 100 + 300 - 130, 90, 120, {
      targetRoom: "yellowHall",
      targetDir: "west",
      targetEntry: { x: 150, y: H/2 - 30 },
      requiredKey: "key-yellow",
      open: false
    });
  });

  addRoom("yellowHall", "Great Hall", {
    neighbors: { west: "yellowCourtyard", east: "royalVault" },
    entryPoints: { default: { x: 150, y: H/2 - 30 } },
    bgColor: "#3c2e1f"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
    room.castle = { color: "#9f7d39", accent: "#ffe7a6", door: "east", label: "Throne", x: 200, y: 140, w: 520, h: 260 };
  });

  addRoom("royalVault", "Royal Vault", {
    neighbors: { west: "yellowHall" },
    bgColor: "#2f2316"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.walls.push(
      { x: 320, y: 120, w: 20, h: 360 },
      { x: 520, y: 120, w: 20, h: 360 }
    );
  });

  addRoom("mazeEntry", "Maze Gate", {
    neighbors: { north: "meadow", west: "mazeSide", east: "mazeCenter" },
    bgColor: "#15221a"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, west: true, east: true } });
    room.walls.push(
      { x: 320, y: 100, w: 20, h: 400 },
      { x: 500, y: 140, w: 20, h: 320 }
    );
  });

  addRoom("mazeSide", "Maze Side", {
    neighbors: { east: "mazeEntry" },
    bgColor: "#121a12"
  }, (room) => {
    addBoundaryWalls(room, { open: { east: true } });
    room.walls.push(
      { x: 240, y: 120, w: 20, h: 360 },
      { x: 520, y: 120, w: 20, h: 360 }
    );
  });

  addRoom("mazeCenter", "Inner Maze", {
    neighbors: { west: "mazeEntry", east: "blackEntrance", south: "greenMaze" },
    bgColor: "#0f1c11"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true, south: true } });
    room.walls.push(
      { x: 200, y: 60, w: 20, h: 360 },
      { x: 400, y: 180, w: 20, h: 360 },
      { x: 600, y: 80, w: 20, h: 360 },
      { x: 400, y: 60, w: 220, h: 20 }
    );
  });

  addRoom("blackEntrance", "Shadow Gate", {
    neighbors: { west: "mazeCenter", east: "blackHall" },
    bgColor: "#141414"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
    room.castle = { color: "#363636", accent: "#dedede", door: "west", label: "Black Castle", x: 300, y: 140, w: 380, h: 260 };
    room.gate = new Gate(W/2 - 45, H/2 - 60, 90, 120, {
      targetRoom: "blackHall",
      targetDir: "west",
      targetEntry: { x: 140, y: H/2 - 30 },
      requiredKey: "key-black",
      open: false
    });
  });

  addRoom("blackHall", "Black Keep", {
    neighbors: { west: "blackEntrance" },
    bgColor: "#1f1f1f"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#252525", accent: "#f7f7f7", door: "east", label: "Vault", x: 220, y: 120, w: 520, h: 300 };
  });

  addRoom("greenMaze", "Lower Maze", {
    neighbors: { north: "mazeCenter", south: "greenEntrance" },
    bgColor: "#143021"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, south: true } });
    room.walls.push(
      { x: 240, y: 80, w: 20, h: 420 },
      { x: 460, y: 80, w: 20, h: 420 },
      { x: 680, y: 80, w: 20, h: 420 }
    );
  });

  addRoom("greenEntrance", "Emerald Gate", {
    neighbors: { north: "greenMaze", east: "greenHall" },
    bgColor: "#1f3a27"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true } });
    room.castle = { color: "#3f6b37", accent: "#d9febc", door: "north", label: "Green Castle", x: 280, y: 140, w: 400, h: 260 };
    room.gate = new Gate(W/2 - 45, H/2 - 60, 90, 120, {
      targetRoom: "greenHall",
      targetDir: "west",
      targetEntry: { x: 140, y: H/2 - 30 },
      requiredKey: "key-green",
      open: false
    });
  });

  addRoom("greenHall", "Emerald Treasury", {
    neighbors: { west: "greenEntrance" },
    bgColor: "#28492f"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#345c31", accent: "#dbffb5", door: "east", label: "Treasure", x: 240, y: 120, w: 520, h: 300 };
  });

  addRoom("swamp", "Bog Lanes", {
    neighbors: { north: "riverbank", east: "dragonLair", south: "swampDepths" },
    bgColor: "#1b2916"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true, south: true } });
    room.walls.push(
      { x: 200, y: 80, w: 120, h: 300 },
      { x: 520, y: 200, w: 160, h: 200 }
    );
  });

  addRoom("swampDepths", "Swamp Depths", {
    neighbors: { north: "swamp" },
    bgColor: "#162114"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true } });
    room.walls.push(
      { x: 240, y: 120, w: 20, h: 360 },
      { x: 520, y: 120, w: 20, h: 360 }
    );
  });

  addRoom("dragonLair", "Dragon Maw", {
    neighbors: { west: "swamp" },
    bgColor: "#2c1010"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.walls.push(
      { x: 220, y: 120, w: 20, h: 320 },
      { x: 220, y: 120, w: 420, h: 20 },
      { x: 220, y: 420, w: 420, h: 20 }
    );
  });

  addRoom("secretNook", "Secret Nook", {
    neighbors: {},
    bgColor: "#10141a"
  }, (room) => {
    addBoundaryWalls(room, {});
    room.walls.push(
      { x: 260, y: 140, w: 20, h: 320 },
      { x: 520, y: 120, w: 20, h: 360 }
    );
  });

  addSecretDoor(world.rooms.greenMaze, { x: 20, y: 80, w: 28, h: 120 }, "secretNook", "east", { x: W - 180, y: H/2 - 20 });

  world.addItemToRoom(new Item("sword", 260, 220, 64, 26), "mazeEntry");
  world.addItemToRoom(new Item("bridge", 200, H/2 + 80, 72, 20), "riverbank");
  world.addItemToRoom(new Item("key-yellow", 320, H/2 + 30, 40, 24), "meadow");
  world.addItemToRoom(new Item("key-black", 320, H/2 + 20, 40, 24), "royalVault");
  world.addItemToRoom(new Item("key-green", 300, H/2 - 10, 40, 24), "blackHall");
  world.addItemToRoom(new Item("key-white", 360, H/2 - 10, 40, 24), "secretNook");
  world.addItemToRoom(new Item("trophy", W - 280, H/2 - 26, 44, 36), "greenHall");

  world.bat = new Bat(260, 160, "mazeCenter");
  const dragonFast = new Dragon(W - 260, H/2 - 32, { speed: 220, aggroRange: 900 });
  const dragonSlow = new Dragon(220, 220, { speed: 140, aggroRange: 700 });
  world.rooms.dragonLair.enemies.push(dragonFast);
  world.rooms.swamp.enemies.push(dragonSlow);

  world.currentRoomId = START_ROOM_ID;
}

function buildCatacombsLayout(world) {
  world.rooms = {};
  const addRoom = createRoomAdder(world);

  addRoom("meadow", "Clifftop Camp", {
    neighbors: { east: "ruins", south: "catGate" },
    entryPoints: { default: { x: 80, y: H/2 - 24 } },
    bgColor: "#1d2316"
  }, (room) => {
    addBoundaryWalls(room, { open: { east: true, south: true } });
    room.pedestal = { x: 48, y: H/2 - 26, w: 110, h: 20 };
  });

  addRoom("ruins", "Overgrown Ruins", {
    neighbors: { west: "meadow", east: "riverWatch", south: "boneYard" },
    bgColor: "#262c1c"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true, south: true } });
    room.walls.push(
      { x: 220, y: 80, w: 20, h: 360 },
      { x: 460, y: 120, w: 20, h: 320 }
    );
  });

  addRoom("riverWatch", "River Watch", {
    neighbors: { west: "ruins", east: "yellowCourtyard", south: "marsh" },
    bgColor: "#132029"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true, south: true } });
    room.walls.push(
      { x: 160, y: 80, w: 20, h: 420 },
      { x: 520, y: 80, w: 20, h: 420 }
    );
  });

  addRoom("yellowCourtyard", "Sunken Yellow Gate", {
    neighbors: { west: "riverWatch" },
    bgColor: "#30251b"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#f4d26a", accent: "#fff2a1", roof: "#b98b41", door: "west", label: "Yellow Castle", x: 300, y: 120, w: 340, h: 260 };
    room.walls = [];
    room.gate = new Gate(300 + 340/2 - 45, 120 + 260 - 130, 90, 120, {
      targetRoom: "yellowHall",
      targetDir: "west",
      targetEntry: { x: 120, y: H/2 - 36 },
      requiredKey: "key-yellow",
      open: false
    });
  });

  addRoom("yellowHall", "Golden Treasury", {
    neighbors: { west: "yellowCourtyard" },
    entryPoints: { default: { x: 120, y: H/2 - 36 } },
    bgColor: "#3a2b1a"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#a77c38", accent: "#ffe3a4", roof: "#7c5221", door: "east", label: "Throne", x: 220, y: 140, w: 500, h: 260 };
  });

  addRoom("catGate", "Catacomb Gate", {
    neighbors: { north: "meadow", south: "catHall" },
    bgColor: "#1a1c21"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, south: true } });
    room.walls.push(
      { x: 360, y: 80, w: 20, h: 420 }
    );
    room.castle = { color: "#4a4d56", accent: "#c7cdd9", door: "south", label: "Catacombs", x: 200, y: 160, w: 360, h: 220 };
  });

  addRoom("catHall", "Catacomb Hall", {
    neighbors: { north: "catGate", east: "catCross", west: "catArchive" },
    bgColor: "#101219"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true, west: true } });
    room.walls.push(
      { x: 300, y: 140, w: 20, h: 320 },
      { x: 520, y: 80, w: 20, h: 420 }
    );
  });

  addRoom("catArchive", "Silent Archive", {
    neighbors: { east: "catHall", south: "crypt" },
    bgColor: "#161820"
  }, (room) => {
    addBoundaryWalls(room, { open: { east: true, south: true } });
  });

  addRoom("crypt", "Deep Crypt", {
    neighbors: { north: "catArchive", east: "ossuary", south: "catVault" },
    bgColor: "#13121a"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true, south: true } });
    room.walls.push(
      { x: 360, y: 60, w: 20, h: 460 }
    );
  });

  addRoom("ossuary", "Ossuary", {
    neighbors: { west: "crypt" },
    bgColor: "#14141c"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.walls.push(
      { x: 260, y: 120, w: 20, h: 360 },
      { x: 520, y: 120, w: 20, h: 360 }
    );
  });

  addRoom("catVault", "Vault of Bones", {
    neighbors: { north: "crypt", south: "floodedCavern" },
    bgColor: "#0f0f15"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, south: true } });
  });

  addRoom("floodedCavern", "Flooded Cavern", {
    neighbors: { north: "catVault" },
    bgColor: "#0f141a"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true } });
    room.walls.push(
      { x: 300, y: 120, w: 20, h: 360 },
      { x: 520, y: 160, w: 20, h: 320 }
    );
  });

  addRoom("catCross", "Catacomb Crossroads", {
    neighbors: { west: "catHall", east: "greenEntrance", south: "lavaTunnel" },
    bgColor: "#15161d"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true, south: true } });
  });

  addRoom("lavaTunnel", "Lava Tunnel", {
    neighbors: { north: "catCross", south: "dragonDen" },
    bgColor: "#2b0d0d"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, south: true } });
    room.walls.push(
      { x: 360, y: 80, w: 20, h: 420 }
    );
  });

  addRoom("dragonDen", "Dragon Den", {
    neighbors: { north: "lavaTunnel", west: "boneYard", east: "greenEntrance" },
    bgColor: "#300e0e"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, west: true, east: true } });
  });

  addRoom("boneYard", "Bone Yard", {
    neighbors: { north: "ruins", east: "dragonDen" },
    bgColor: "#27180f"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true } });
  });

  addRoom("marsh", "Weeping Marsh", {
    neighbors: { north: "riverWatch", east: "blackEntrance", south: "obsidianPass" },
    bgColor: "#132119"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true, south: true } });
  });

  addRoom("obsidianPass", "Obsidian Pass", {
    neighbors: { north: "marsh", south: "blackHall" },
    bgColor: "#1f141c"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, south: true } });
  });

  addRoom("blackEntrance", "Black Gate", {
    neighbors: { west: "marsh", east: "blackHall" },
    bgColor: "#0f0f0f"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
    room.castle = { color: "#3a3a3a", accent: "#cfcfcf", roof: "#222", door: "west", label: "Black Castle", x: 320, y: 140, w: 360, h: 260 };
    room.gate = new Gate(W/2 - 45, H/2 - 60, 90, 120, {
      targetRoom: "blackHall",
      targetDir: "west",
      targetEntry: { x: 140, y: H/2 - 30 },
      requiredKey: "key-black",
      open: false
    });
  });

  addRoom("blackHall", "Shadow Keep", {
    neighbors: { west: "blackEntrance" },
    bgColor: "#1c1c1c"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#272727", accent: "#f5f5f5", roof: "#555", door: "east", label: "Dungeon", x: 240, y: 120, w: 500, h: 280 };
  });

  addRoom("greenEntrance", "Green Gate", {
    neighbors: { west: "catCross", east: "greenHall" },
    bgColor: "#18321b"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
    room.gate = new Gate(W/2 - 45, H/2 - 60, 90, 120, {
      targetRoom: "greenHall",
      targetDir: "west",
      targetEntry: { x: 140, y: H/2 - 30 },
      requiredKey: "key-green",
      open: false
    });
    room.castle = { color: "#466b3d", accent: "#c4f0ad", roof: "#2d4e29", door: "west", label: "Green Castle", x: 300, y: 150, w: 360, h: 240 };
  });

  addRoom("greenHall", "Emerald Vault", {
    neighbors: { west: "greenEntrance" },
    bgColor: "#234026",
    entryPoints: { west: { x: 140, y: H/2 - 30 }, default: { x: 140, y: H/2 - 30 } }
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#33522f", accent: "#d4ffbf", roof: "#1f311f", door: "east", label: "Vault", x: 240, y: 140, w: 500, h: 260 };
  });

  addRoom("sealedSanctum", "Sealed Sanctum", {
    neighbors: {},
    bgColor: "#111018"
  }, (room) => {
    addBoundaryWalls(room, {});
    room.walls.push(
      { x: 260, y: 120, w: 20, h: 360 },
      { x: 520, y: 120, w: 20, h: 360 }
    );
  });

  addSecretDoor(world.rooms.catArchive, { x: 20, y: H/2 - 60, w: 28, h: 120 }, "sealedSanctum", "east", { x: W - 180, y: H/2 - 20 });

  world.addItemToRoom(new Item("sword", 160, H/2 - 18, 60, 26), "ruins");
  world.addItemToRoom(new Item("bridge", 220, H/2 + 80, 72, 20), "catHall");
  world.addItemToRoom(new Item("key-yellow", 240, H/2 - 20, 40, 24), "riverWatch");
  world.addItemToRoom(new Item("key-black", 320, H/2 + 20, 40, 24), "yellowHall");
  world.addItemToRoom(new Item("key-green", 320, H/2 - 10, 40, 24), "blackHall");
  world.addItemToRoom(new Item("key-white", 360, H/2 - 10, 40, 24), "sealedSanctum");
  world.addItemToRoom(new Item("trophy", W - 260, H/2 - 24, 44, 36), "greenHall");

  world.bat = new Bat(260, 160, "catHall");
  const dragonA = new Dragon(W - 260, H/2 - 40, { speed: 220, aggroRange: 900 });
  const dragonB = new Dragon(200, 240, { speed: 140, aggroRange: 700 });
  world.rooms.dragonDen.enemies.push(dragonA);
  world.rooms.marsh.enemies.push(dragonB);

  world.currentRoomId = START_ROOM_ID;
}

function buildHighlandsLayout(world) {
  world.rooms = {};
  const addRoom = createRoomAdder(world);

  addRoom("meadow", "Highland Meadow", {
    neighbors: { east: "ridge", south: "forest" },
    entryPoints: { default: { x: 80, y: H/2 - 24 } },
    bgColor: "#1c2a1a"
  }, (room) => {
    addBoundaryWalls(room, { open: { east: true, south: true } });
    room.pedestal = { x: 60, y: H/2 - 24, w: 120, h: 20 };
  });

  addRoom("ridge", "Windy Ridge", {
    neighbors: { west: "meadow", east: "yellowCourtyard", south: "lakePass" },
    bgColor: "#222f1f"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true, south: true } });
  });

  addRoom("forest", "Pine Forest", {
    neighbors: { north: "meadow", east: "lakePass", south: "swamp" },
    bgColor: "#152417"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true, south: true } });
  });

  addRoom("lakePass", "Lake Pass", {
    neighbors: { north: "ridge", west: "forest", east: "greenEntrance", south: "cavernMouth" },
    bgColor: "#0f2331"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, west: true, east: true, south: true } });
  });

  addRoom("yellowCourtyard", "Yellow Outpost", {
    neighbors: { west: "ridge", south: "cliffRoad" },
    bgColor: "#302615"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, south: true } });
    room.castle = { color: "#f2d37b", accent: "#fff6b0", roof: "#b9853f", door: "west", label: "Yellow Castle", x: 300, y: 110, w: 360, h: 260 };
    room.walls = [];
    room.gate = new Gate(300 + 360/2 - 45, 110 + 260 - 130, 90, 120, {
      targetRoom: "yellowHall",
      targetDir: "west",
      targetEntry: { x: 120, y: H/2 - 40 },
      requiredKey: "key-yellow",
      open: false
    });
  });

  addRoom("yellowHall", "Golden Hall", {
    neighbors: { west: "yellowCourtyard" },
    bgColor: "#3a2c17"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#9d7634", accent: "#ffe5a2", roof: "#734d1d", door: "east", label: "Throne", x: 220, y: 140, w: 520, h: 260 };
  });

  addRoom("cliffRoad", "Cliff Road", {
    neighbors: { north: "yellowCourtyard", east: "cavernMouth", south: "coast" },
    bgColor: "#1e1f29"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true, south: true } });
  });

  addRoom("coast", "Rocky Coast", {
    neighbors: { north: "cliffRoad", east: "harbor" },
    bgColor: "#0f1b29"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true } });
  });

  addRoom("harbor", "Abandoned Harbor", {
    neighbors: { west: "coast", east: "lighthouse" },
    bgColor: "#102031"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
  });

  addRoom("lighthouse", "Lighthouse", {
    neighbors: { west: "harbor" },
    bgColor: "#0f1a26"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.walls.push(
      { x: 300, y: 120, w: 20, h: 360 },
      { x: 520, y: 120, w: 20, h: 360 }
    );
  });

  addRoom("swamp", "Sunken Swamp", {
    neighbors: { north: "forest", west: "mireEdge", east: "blackEntrance", south: "bogDepths" },
    bgColor: "#152515"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, west: true, east: true, south: true } });
  });

  addRoom("mireEdge", "Mire Edge", {
    neighbors: { east: "swamp" },
    bgColor: "#111f14"
  }, (room) => {
    addBoundaryWalls(room, { open: { east: true } });
    room.walls.push(
      { x: 240, y: 120, w: 20, h: 360 },
      { x: 520, y: 120, w: 20, h: 360 }
    );
  });

  addRoom("bogDepths", "Bog Depths", {
    neighbors: { north: "swamp", east: "blackEntrance" },
    bgColor: "#101e10"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true } });
  });

  addRoom("blackEntrance", "Black Rampart", {
    neighbors: { west: "swamp", east: "blackHall" },
    bgColor: "#101010"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
    room.castle = { color: "#3c3c3c", accent: "#cfcfcf", roof: "#202020", door: "west", label: "Black Castle", x: 320, y: 140, w: 360, h: 260 };
    room.gate = new Gate(W/2 - 45, H/2 - 60, 90, 120, {
      targetRoom: "blackHall",
      targetDir: "west",
      targetEntry: { x: 140, y: H/2 - 30 },
      requiredKey: "key-black",
      open: false
    });
  });

  addRoom("blackHall", "Shadow Citadel", {
    neighbors: { west: "blackEntrance" },
    bgColor: "#1f1f1f"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#2a2a2a", accent: "#f2f2f2", roof: "#555", door: "east", label: "Dungeon", x: 240, y: 120, w: 520, h: 280 };
  });

  addRoom("greenEntrance", "Green Spire Gate", {
    neighbors: { west: "lakePass", east: "greenHall" },
    bgColor: "#17311b"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
    room.gate = new Gate(W/2 - 45, H/2 - 60, 90, 120, {
      targetRoom: "greenHall",
      targetDir: "west",
      targetEntry: { x: 140, y: H/2 - 28 },
      requiredKey: "key-green",
      open: false
    });
    room.castle = { color: "#436c38", accent: "#d2feb8", roof: "#264627", door: "west", label: "Green Castle", x: 300, y: 140, w: 360, h: 240 };
  });

  addRoom("greenHall", "Emerald Hall", {
    neighbors: { west: "greenEntrance" },
    bgColor: "#224428",
    entryPoints: { west: { x: 140, y: H/2 - 28 }, default: { x: 140, y: H/2 - 28 } }
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.castle = { color: "#33542f", accent: "#dcffbe", roof: "#223122", door: "east", label: "Vault", x: 260, y: 140, w: 520, h: 260 };
  });

  addRoom("cavernMouth", "Cavern Mouth", {
    neighbors: { north: "lakePass", east: "cavernDepths", south: "dragonLair", west: "cliffRoad" },
    bgColor: "#1a1b27"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true, south: true, west: true } });
  });

  addRoom("cavernDepths", "Cavern Depths", {
    neighbors: { west: "cavernMouth", east: "towerGate", south: "lavaSea" },
    bgColor: "#191728"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true, south: true } });
  });

  addRoom("towerGate", "Sky Tower Gate", {
    neighbors: { west: "cavernDepths", east: "towerTop" },
    bgColor: "#202138"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
    room.castle = { color: "#5364a3", accent: "#d5deff", roof: "#2c366b", towers: 1, door: "east", label: "Sky Tower", x: 300, y: 90, w: 360, h: 300 };
  });

  addRoom("towerTop", "Sky Tower", {
    neighbors: { west: "towerGate" },
    bgColor: "#2a2f46"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
  });

  addRoom("lavaSea", "Lava Sea", {
    neighbors: { north: "cavernDepths", south: "gauntletHall" },
    bgColor: "#330f0f"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, south: true } });
  });

  addRoom("gauntletHall", "Inferno Gauntlet", {
    neighbors: { north: "lavaSea" },
    bgColor: "#3a0d0d"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true } });
  });

  addRoom("dragonLair", "Dragon Lair", {
    neighbors: { north: "cavernMouth" },
    bgColor: "#311010"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true } });
  });

  addRoom("hiddenVault", "Hidden Vault", {
    neighbors: {},
    bgColor: "#10141a"
  }, (room) => {
    addBoundaryWalls(room, {});
    room.walls.push(
      { x: 260, y: 120, w: 20, h: 360 },
      { x: 520, y: 120, w: 20, h: 360 }
    );
  });

  addSecretDoor(world.rooms.cavernDepths, { x: W - 36, y: H/2 - 60, w: 28, h: 120 }, "hiddenVault", "west", { x: 140, y: H/2 - 20 });

  world.addItemToRoom(new Item("sword", 200, H/2 - 16, 60, 24), "ridge");
  world.addItemToRoom(new Item("bridge", 220, H/2 + 80, 72, 20), "lakePass");
  world.addItemToRoom(new Item("key-yellow", 220, H/2 + 20, 40, 24), "forest");
  world.addItemToRoom(new Item("key-black", 320, H/2 + 20, 40, 24), "yellowHall");
  world.addItemToRoom(new Item("key-green", 300, H/2 - 10, 40, 24), "blackHall");
  world.addItemToRoom(new Item("key-white", 360, H/2 - 10, 40, 24), "hiddenVault");
  world.addItemToRoom(new Item("trophy", W - 240, H/2 - 24, 44, 36), "towerTop");

  world.bat = new Bat(240, 160, "lakePass");
  const dragonHigh = new Dragon(240, H/2 - 40, { speed: 220, aggroRange: 900 });
  const dragonLow = new Dragon(W - 220, 200, { speed: 140, aggroRange: 700 });
  world.rooms.dragonLair.enemies.push(dragonHigh);
  world.rooms.swamp.enemies.push(dragonLow);

  world.currentRoomId = START_ROOM_ID;
}

function buildGauntletLayout(world) {
  world.rooms = {};
  const addRoom = createRoomAdder(world);

  addRoom("meadow", "Frontier Camp", {
    neighbors: { east: "fields", south: "tangle" },
    entryPoints: { default: { x: 84, y: H/2 - 24 } },
    bgColor: "#202418"
  }, (room) => {
    addBoundaryWalls(room, { open: { east: true, south: true } });
    room.pedestal = { x: 60, y: H/2 - 24, w: 120, h: 20 };
  });

  addRoom("fields", "Rolling Fields", {
    neighbors: { west: "meadow", east: "fortGate", south: "riverSouth" },
    bgColor: "#27311d"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true, south: true } });
  });

  addRoom("fortGate", "Fortress Gate", {
    neighbors: { west: "fields", east: "fortHall", south: "cliffPass" },
    bgColor: "#2f261d"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true, south: true } });
    room.castle = { color: "#e4c36d", accent: "#fff4ab", roof: "#b07c36", door: "west", label: "Fortress", x: 320, y: 110, w: 360, h: 260 };
    room.gate = new Gate(W/2 - 45, H/2 - 60, 90, 120, {
      targetRoom: "fortHall",
      targetDir: "west",
      targetEntry: { x: 120, y: H/2 - 40 },
      requiredKey: "key-yellow",
      open: false
    });
  });

  addRoom("fortHall", "Fortress Hall", {
    neighbors: { west: "fortGate", east: "towerHall" },
    bgColor: "#3b2b1f"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
  });

  addRoom("towerHall", "Tower Hall", {
    neighbors: { west: "fortHall", east: "eastReach" },
    bgColor: "#322c3d"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
    room.castle = { color: "#4d5f9a", accent: "#dbe4ff", roof: "#273469", door: "east", label: "Sky Tower", x: 260, y: 100, w: 460, h: 300 };
  });

  addRoom("eastReach", "East Reach", {
    neighbors: { west: "towerHall" },
    bgColor: "#2a2d3f"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
    room.walls.push(
      { x: 300, y: 120, w: 20, h: 360 },
      { x: 520, y: 120, w: 20, h: 360 }
    );
  });

  addRoom("tangle", "Thorn Tangle", {
    neighbors: { north: "meadow", east: "riverSouth", south: "shadowGlade" },
    bgColor: "#162116"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true, south: true } });
  });

  addRoom("riverSouth", "Southern River", {
    neighbors: { north: "fields", west: "tangle", east: "greenEntrance", south: "delta" },
    bgColor: "#102333"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, west: true, east: true, south: true } });
  });

  addRoom("delta", "Delta Flats", {
    neighbors: { north: "riverSouth", east: "obsidianGate" },
    bgColor: "#122223"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true } });
  });

  addRoom("obsidianGate", "Obsidian Gate", {
    neighbors: { west: "delta", east: "obsidianHall" },
    bgColor: "#111015"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
    room.castle = { color: "#3a3a3a", accent: "#dedede", roof: "#232323", door: "west", label: "Black Castle", x: 320, y: 140, w: 360, h: 260 };
  });

  addRoom("obsidianHall", "Obsidian Hall", {
    neighbors: { west: "obsidianGate" },
    bgColor: "#1c1c1c"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
  });

  addRoom("shadowGlade", "Shadow Glade", {
    neighbors: { north: "tangle", east: "marshEast", south: "dragonAerie" },
    bgColor: "#101b13"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true, south: true } });
  });

  addRoom("marshEast", "Eastern Marsh", {
    neighbors: { west: "shadowGlade", east: "blackEntrance", south: "catacombGate" },
    bgColor: "#162616"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true, south: true } });
  });

  addRoom("blackEntrance", "Black Fortress Gate", {
    neighbors: { west: "marshEast", east: "blackHall" },
    bgColor: "#0f0f0f"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
    room.castle = { color: "#404040", accent: "#dcdcdc", roof: "#242424", door: "west", label: "Black Fortress", x: 320, y: 140, w: 360, h: 260 };
    room.gate = new Gate(W/2 - 45, H/2 - 60, 90, 120, {
      targetRoom: "blackHall",
      targetDir: "west",
      targetEntry: { x: 140, y: H/2 - 30 },
      requiredKey: "key-black",
      open: false
    });
  });

  addRoom("blackHall", "Black Fortress", {
    neighbors: { west: "blackEntrance" },
    bgColor: "#1d1d1d"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
  });

  addRoom("catacombGate", "Catacomb Gate", {
    neighbors: { north: "marshEast", south: "catacombDepths" },
    bgColor: "#161219"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, south: true } });
  });

  addRoom("catacombDepths", "Depths", {
    neighbors: { north: "catacombGate", east: "lavaBridge" },
    bgColor: "#141018"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, east: true } });
  });

  addRoom("lavaBridge", "Lava Bridge", {
    neighbors: { west: "catacombDepths", east: "dragonAerie" },
    bgColor: "#2f0c0c"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
  });

  addRoom("dragonAerie", "Dragon Aerie", {
    neighbors: { north: "shadowGlade", west: "lavaBridge", east: "towerHall", south: "ashWastes" },
    bgColor: "#330f0f"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true, west: true, east: true, south: true } });
  });

  addRoom("ashWastes", "Ash Wastes", {
    neighbors: { north: "dragonAerie" },
    bgColor: "#2b0f12"
  }, (room) => {
    addBoundaryWalls(room, { open: { north: true } });
    room.walls.push(
      { x: 240, y: 120, w: 20, h: 360 },
      { x: 520, y: 140, w: 20, h: 340 }
    );
  });

  addRoom("greenEntrance", "Verdant Gate", {
    neighbors: { west: "riverSouth", east: "greenHall" },
    bgColor: "#163018"
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true, east: true } });
    room.castle = { color: "#3f6534", accent: "#c6f7b2", roof: "#274326", door: "west", label: "Green Castle", x: 300, y: 150, w: 360, h: 240 };
    room.gate = new Gate(W/2 - 45, H/2 - 60, 90, 120, {
      targetRoom: "greenHall",
      targetDir: "west",
      targetEntry: { x: 140, y: H/2 - 30 },
      requiredKey: "key-green",
      open: false
    });
  });

  addRoom("greenHall", "Verdant Hall", {
    neighbors: { west: "greenEntrance" },
    bgColor: "#214224",
    entryPoints: { west: { x: 140, y: H/2 - 30 }, default: { x: 140, y: H/2 - 30 } }
  }, (room) => {
    addBoundaryWalls(room, { open: { west: true } });
  });

  addRoom("lostVault", "Lost Vault", {
    neighbors: {},
    bgColor: "#121118"
  }, (room) => {
    addBoundaryWalls(room, {});
    room.walls.push(
      { x: 260, y: 120, w: 20, h: 360 },
      { x: 520, y: 120, w: 20, h: 360 }
    );
  });

  addSecretDoor(world.rooms.catacombDepths, { x: 20, y: H/2 - 60, w: 28, h: 120 }, "lostVault", "east", { x: W - 180, y: H/2 - 20 });

  world.addItemToRoom(new Item("sword", 220, H/2 - 18, 60, 24), "fields");
  world.addItemToRoom(new Item("bridge", 220, H/2 + 80, 72, 20), "riverSouth");
  world.addItemToRoom(new Item("key-yellow", 220, H/2 + 20, 40, 24), "tangle");
  world.addItemToRoom(new Item("key-black", W - 220, H/2 - 20, 40, 24), "obsidianHall");
  world.addItemToRoom(new Item("key-green", 300, H/2 - 10, 40, 24), "blackHall");
  world.addItemToRoom(new Item("key-white", 360, H/2 - 10, 40, 24), "lostVault");
  world.addItemToRoom(new Item("trophy", W - 240, H/2 - 26, 44, 36), "towerHall");

  world.bat = new Bat(260, 160, "delta");
  const dragonOne = new Dragon(W - 280, 180, { speed: 220, aggroRange: 900 });
  const dragonTwo = new Dragon(200, H/2 - 32, { speed: 140, aggroRange: 700 });
  world.rooms.dragonAerie.enemies.push(dragonOne);
  world.rooms.ashWastes.enemies.push(dragonTwo);

  world.currentRoomId = START_ROOM_ID;
}

const state = {
  paused: false,
  winTimer: 0
};

/* =========================================================
   Input edge detection (pressed once)
   ========================================================= */

const _pressed = new Set();
addEventListener("keydown", (e) => {
  if (!shouldCaptureKey(e)) return;
  const k = e.key.toLowerCase();
  if (!_pressed.has(k)) _pressed.add(k);
});
function wasPressed(k) {
  k = k.toLowerCase();
  if (_pressed.has(k)) { _pressed.delete(k); return true; }
  return false;
}

const _touchActions = { interact: false, drop: false };
function touchActionPressed(action) {
  if (_touchActions[action]) {
    _touchActions[action] = false;
    return true;
  }
  return false;
}

/* =========================================================
   Game loop
   ========================================================= */

let last = 0;
function perfNow(){ return performance.now(); }

function loop(ts) {
  const dt = Math.min(0.033, (ts - last) / 1000);
  last = ts;

  // toggles
  if (wasPressed("p")) { state.paused = !state.paused; showToast(state.paused ? "Paused" : "Resumed"); }
  if (wasPressed("r")) { WORLD.resetAll(); showToast("Reset"); }

  if (!state.paused) {
    WORLD.update(dt);
    if (state.winTimer > 0) {
      state.winTimer += dt;
    }
  }

  // draw
  WORLD.draw();

  // HUD
  renderHUD();

  // win banner
  if (state.winTimer > 0) {
    ctx.fillStyle = "rgba(0,0,0,.55)";
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = "#e8eef8";
    ctx.font = "bold 42px system-ui, sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("You Win!", W/2, H/2 - 20);
    ctx.font = "16px system-ui, sans-serif";
    ctx.fillStyle = "#aab4c0";
    ctx.fillText("Press R to play again", W/2, H/2 + 24);
  }

  requestAnimationFrame(loop);
}

let lastHudState = "";
function renderHUD() {
  const hud = document.getElementById("hud");
  if (!hud) return;
  const room = WORLD.current();
  const holding = WORLD.player.holding ? itemDisplayName(WORLD.player.holding.kind) : "";
  const gateState = room.gate ? (room.gate.open ? "Open" : "Closed") : "";
  const layoutName = WORLD.currentLayoutName || "";
  const nextState = [
    activeLevelName,
    activeKidName,
    layoutName,
    room.name,
    holding,
    gateState
  ].join("|");
  if (nextState === lastHudState) return;
  lastHudState = nextState;
  hud.innerHTML = "";
  const tag = (t)=>{ const el=document.createElement("div"); el.className="tag"; el.textContent=t; return el; };
  hud.append(tag(`Level: ${activeLevelName}`));
  hud.append(tag(`Kid: ${activeKidName}`));
  if (layoutName) {
    hud.append(tag(`Layout: ${layoutName}`));
  }
  hud.append(tag(`Room: ${room.name}`));
  if (holding) hud.append(tag(`Holding: ${holding}`));
  if (gateState) hud.append(tag(`Gate: ${gateState}`));
}

/* =========================================================
   Buttons
   ========================================================= */

document.getElementById("btnReset").addEventListener("click", ()=>{ WORLD.resetAll(); showToast("Reset"); });
document.getElementById("btnPause").addEventListener("click", ()=>{ state.paused=!state.paused; showToast(state.paused ? "Paused" : "Resumed"); });

function setupTouchControls() {
  const pad = document.getElementById("touchPad");
  if (!pad) return;
  const startDir = (dir) => { touchState[dir] = true; };
  const stopDir = (dir) => { touchState[dir] = false; };

  pad.querySelectorAll("[data-dir]").forEach(btn => {
    const dir = btn.getAttribute("data-dir");
    const start = (ev) => {
      ev.preventDefault();
      startDir(dir);
    };
    const end = (ev) => {
      ev.preventDefault();
      stopDir(dir);
    };
    btn.addEventListener("touchstart", start);
    btn.addEventListener("mousedown", start);
    btn.addEventListener("touchend", end);
    btn.addEventListener("touchcancel", end);
    btn.addEventListener("mouseup", end);
    btn.addEventListener("mouseleave", end);
  });

  document.querySelectorAll(".touch-actions .touch-btn").forEach(btn => {
    const action = btn.dataset.action;
    btn.addEventListener("click", (ev) => {
      ev.preventDefault();
      _touchActions[action] = true;
    });
    btn.addEventListener("touchstart", (ev) => {
      ev.preventDefault();
      _touchActions[action] = true;
    });
  });
}

/* =========================================================
   Start
   ========================================================= */

WORLD.resetAll();
setupTouchControls();
requestAnimationFrame((t)=>{ last=t; requestAnimationFrame(loop); });
</script>
</body>
</html>
